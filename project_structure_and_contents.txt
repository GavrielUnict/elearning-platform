Struttura del progetto  
(tree -a -I ".git|.vscode|target|.terraform|.elasticbeanstalk|.terraform.lock.hcl|node_modules|test-cognito.sh|ScriptDiSupporto.sh|project_structure_and_contents.txt"):

.
├── .gitignore
├── deploy-all.sh
├── docs
├── src
│   ├── ecs-container
│   │   ├── .dockerignore
│   │   ├── Dockerfile
│   │   ├── build-and-push.sh
│   │   ├── main.py
│   │   └── requirements.txt
│   ├── frontend
│   │   ├── .dockerignore
│   │   ├── .env.production
│   │   ├── .gitignore
│   │   ├── Dockerfile
│   │   ├── Dockerrun.aws.json
│   │   ├── build
│   │   │   ├── asset-manifest.json
│   │   │   ├── index.html
│   │   │   └── static
│   │   │       ├── css
│   │   │       │   ├── main.233b3b67.css
│   │   │       │   └── main.233b3b67.css.map
│   │   │       └── js
│   │   │           ├── main.c43737fe.js
│   │   │           ├── main.c43737fe.js.LICENSE.txt
│   │   │           └── main.c43737fe.js.map
│   │   ├── deploy.sh
│   │   ├── deploy.zip
│   │   ├── nginx.conf
│   │   ├── package-lock.json
│   │   ├── package.json
│   │   ├── public
│   │   │   └── index.html
│   │   ├── src
│   │   │   ├── App.js
│   │   │   ├── aws-config.js
│   │   │   ├── components
│   │   │   │   ├── auth
│   │   │   │   │   ├── ForgotPassword.jsx
│   │   │   │   │   ├── Login.jsx
│   │   │   │   │   └── Register.jsx
│   │   │   │   ├── common
│   │   │   │   │   ├── Header.jsx
│   │   │   │   │   ├── LoadingSpinner.jsx
│   │   │   │   │   └── PrivateRoute.jsx
│   │   │   │   ├── student
│   │   │   │   │   ├── CourseList.jsx
│   │   │   │   │   ├── CourseView.jsx
│   │   │   │   │   ├── QuizRunner.jsx
│   │   │   │   │   ├── ResultsHistory.jsx
│   │   │   │   │   └── StudentDashboard.jsx
│   │   │   │   └── teacher
│   │   │   │       ├── CourseManager.jsx
│   │   │   │       ├── DocumentUpload.jsx
│   │   │   │       ├── EnrollmentApproval.jsx
│   │   │   │       └── TeacherDashboard.jsx
│   │   │   ├── hooks
│   │   │   │   ├── useAuth.js
│   │   │   │   └── useCourses.js
│   │   │   ├── index.css
│   │   │   ├── index.js
│   │   │   ├── services
│   │   │   │   ├── api.js
│   │   │   │   ├── auth.js
│   │   │   │   └── storage.js
│   │   │   └── utils
│   │   │       └── constants.js
│   │   └── terraform.tfstate
│   └── lambda
└── terraform
    ├── README.md
    ├── environments
    │   └── dev
    │       └── main.tf
    ├── main.tf
    ├── modules
    │   ├── cicd
    │   ├── cognito
    │   │   ├── lambda-functions
    │   │   │   ├── README.md
    │   │   │   ├── post-confirmation
    │   │   │   │   └── index.js
    │   │   │   ├── post-confirmation.zip
    │   │   │   ├── pre-authentication
    │   │   │   │   └── index.js
    │   │   │   └── pre-authentication.zip
    │   │   ├── lambda.tf
    │   │   ├── main.tf
    │   │   ├── outputs.tf
    │   │   └── variables.tf
    │   ├── compute
    │   │   ├── README.md
    │   │   ├── api_cors.tf
    │   │   ├── api_gateway.tf
    │   │   ├── api_gateway_cors_fix.tf
    │   │   ├── functions
    │   │   │   ├── approve-enrollment
    │   │   │   │   └── index.js
    │   │   │   ├── approve-enrollment.zip
    │   │   │   ├── create-course
    │   │   │   │   └── index.js
    │   │   │   ├── create-course.zip
    │   │   │   ├── get-presigned-url
    │   │   │   │   └── index.js
    │   │   │   ├── get-presigned-url.zip
    │   │   │   ├── get-quiz
    │   │   │   │   └── index.js
    │   │   │   ├── get-quiz.zip
    │   │   │   ├── list-courses
    │   │   │   │   └── index.js
    │   │   │   ├── list-courses.zip
    │   │   │   ├── list-documents
    │   │   │   │   └── index.js
    │   │   │   ├── list-documents.zip
    │   │   │   ├── list-enrollments
    │   │   │   │   └── index.js
    │   │   │   ├── list-enrollments.zip
    │   │   │   ├── list-results
    │   │   │   │   └── index.js
    │   │   │   ├── list-results.zip
    │   │   │   ├── manage-course
    │   │   │   │   └── index.js
    │   │   │   ├── manage-course.zip
    │   │   │   ├── manage-document
    │   │   │   │   └── index.js
    │   │   │   ├── manage-document.zip
    │   │   │   ├── request-enrollment
    │   │   │   │   └── index.js
    │   │   │   ├── request-enrollment.zip
    │   │   │   ├── submit-quiz-results
    │   │   │   │   └── index.js
    │   │   │   └── submit-quiz-results.zip
    │   │   ├── lambda_courses.tf
    │   │   ├── lambda_documents.tf
    │   │   ├── lambda_enrollments.tf
    │   │   ├── lambda_layer.tf
    │   │   ├── layers
    │   │   │   ├── shared
    │   │   │   │   └── nodejs
    │   │   │   │       ├── package.json
    │   │   │   │       └── utils.js
    │   │   │   └── shared-layer.zip
    │   │   ├── outputs.tf
    │   │   ├── prepare-lambda-functions.sh
    │   │   └── variables.tf
    │   ├── compute_ecs
    │   │   ├── functions
    │   │   │   ├── ecs-orchestrator
    │   │   │   │   ├── index.js
    │   │   │   │   ├── package-lock.json
    │   │   │   │   └── package.json
    │   │   │   └── ecs-orchestrator.zip
    │   │   ├── iam.tf
    │   │   ├── lambda_orchestrator.tf
    │   │   ├── main.tf
    │   │   ├── outputs.tf
    │   │   ├── prepare-lambda.sh
    │   │   └── variables.tf
    │   ├── elastic_beanstalk
    │   │   ├── main.tf
    │   │   ├── outputs.tf
    │   │   └── variables.tf
    │   ├── messaging
    │   │   ├── main.tf
    │   │   ├── outputs.tf
    │   │   └── variables.tf
    │   ├── networking
    │   │   ├── main.tf
    │   │   ├── outputs.tf
    │   │   ├── security.tf
    │   │   └── variables.tf
    │   └── storage
    │       ├── dynamodb.tf
    │       ├── outputs.tf
    │       ├── s3.tf
    │       └── variables.tf
    ├── outputs.tf
    ├── s3_notifications.tf
    ├── terraform.tfstate
    ├── terraform.tfstate.backup
    ├── terraform.tfvars
    └── variables.tf

52 directories, 131 files



PATH: /elearning-platform/src/ecs-container/.dockerignore

__pycache__
*.pyc
*.pyo
*.pyd
.Python
env/
venv/
.venv/
pip-log.txt
pip-delete-this-directory.txt
.tox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.log
.git
.gitignore
.mypy_cache
.pytest_cache
.hypothesis


PATH: /elearning-platform/src/ecs-container/Dockerfile

FROM python:3.11-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Set working directory
WORKDIR /app

# Copy requirements
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Expose port for health check
EXPOSE 8000

# Run the application
CMD ["python", "main.py"]


PATH: /elearning-platform/src/ecs-container/main.py

import os
import json
import asyncio
from typing import List, Dict
import boto3
from fastapi import FastAPI, HTTPException
import uvicorn
from pydantic import BaseModel
from openai import OpenAI
from datetime import datetime
import logging
import re

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI()

# AWS clients
s3 = boto3.client('s3')
textract = boto3.client('textract')
dynamodb = boto3.resource('dynamodb')
secrets_manager = boto3.client('secretsmanager')

# Environment variables
DOCUMENTS_BUCKET = os.environ['DOCUMENTS_BUCKET']
DOCUMENTS_TABLE = os.environ['DOCUMENTS_TABLE']
QUIZZES_TABLE = os.environ['QUIZZES_TABLE']
OPENAI_API_KEY_SECRET = os.environ['OPENAI_API_KEY_SECRET_NAME']

# Global variable for OpenAI client
openai_client = None

# Get OpenAI API key from Secrets Manager
def get_openai_api_key():
    try:
        response = secrets_manager.get_secret_value(SecretId=OPENAI_API_KEY_SECRET)
        return response['SecretString']
    except Exception as e:
        logger.error(f"Failed to get OpenAI API key: {e}")
        raise

# Initialize OpenAI client
def get_openai_client():
    global openai_client
    if openai_client is None:
        openai_client = OpenAI(api_key=get_openai_api_key())
    return openai_client

# Models
class QuizQuestion(BaseModel):
    question: str
    options: List[str]
    correct_answer: int  # Index of correct option (0-3)

class ProcessingResult(BaseModel):
    status: str
    quiz_id: str = None
    error: str = None

# Health check endpoint
@app.get("/health")
async def health_check():
    return {"status": "healthy"}

# Main processing function
async def process_document():
    """Main function to process document when container starts"""
    try:
        # Get document info from environment
        document_id = os.environ.get('DOCUMENT_ID')
        course_id = os.environ.get('COURSE_ID')
        s3_key = os.environ.get('S3_KEY')
        
        if not all([document_id, course_id, s3_key]):
            raise ValueError("Missing required environment variables")
        
        logger.info(f"Processing document {document_id} from course {course_id}")
        
        # 1. Download PDF from S3
        logger.info("Downloading PDF from S3...")
        pdf_content = s3.get_object(Bucket=DOCUMENTS_BUCKET, Key=s3_key)['Body'].read()
        
        # 2. Extract text using Textract - Asynchronous operation
        logger.info("Starting asynchronous text extraction with Textract...")

        # Start asynchronous job
        start_response = textract.start_document_text_detection(
            DocumentLocation={
                'S3Object': {
                    'Bucket': DOCUMENTS_BUCKET,
                    'Name': s3_key
                }
            }
        )

        job_id = start_response['JobId']
        logger.info(f"Textract job started: {job_id}")

        # Poll for results
        max_attempts = 30
        attempt = 0
        while attempt < max_attempts:
            response = textract.get_document_text_detection(JobId=job_id)
            status = response['JobStatus']
            
            if status == 'SUCCEEDED':
                logger.info("Textract job completed successfully")
                break
            elif status == 'FAILED':
                raise Exception(f"Textract job failed: {response.get('StatusMessage', 'Unknown error')}")
            
            logger.info(f"Job status: {status}, waiting...")
            await asyncio.sleep(5)
            attempt += 1

        if attempt >= max_attempts:
            raise Exception("Textract job timed out")

        # Extract text from results
        extracted_text = ""
        for page in response.get('Blocks', []):
            if page['BlockType'] == 'LINE':
                extracted_text += page['Text'] + "\n"

        # Handle pagination if needed
        next_token = response.get('NextToken')
        while next_token:
            response = textract.get_document_text_detection(JobId=job_id, NextToken=next_token)
            for page in response.get('Blocks', []):
                if page['BlockType'] == 'LINE':
                    extracted_text += page['Text'] + "\n"
            next_token = response.get('NextToken')
        
        # Limit text length for API call
        max_chars = 10000
        if len(extracted_text) > max_chars:
            extracted_text = extracted_text[:max_chars] + "..."
        
        logger.info(f"Extracted {len(extracted_text)} characters")
        
        # 3. Generate quiz using OpenAI
        logger.info("Generating quiz with OpenAI...")
        quiz_questions = await generate_quiz(extracted_text)
        
        # 4. Save quiz to DynamoDB
        logger.info("Saving quiz to DynamoDB...")
        quiz_id = f"quiz-{document_id}-{datetime.utcnow().strftime('%Y%m%d%H%M%S')}"
        
        quizzes_table = dynamodb.Table(QUIZZES_TABLE)
        quiz_item = {
            'documentId': document_id,
            'quizId': quiz_id,
            'questions': [
                {
                    'questionId': f"q{i+1}",
                    'question': q.question,
                    'options': q.options,
                    'correctAnswer': q.correct_answer
                }
                for i, q in enumerate(quiz_questions)
            ],
            'generatedAt': datetime.utcnow().isoformat(),
            'courseId': course_id
        }
        quizzes_table.put_item(Item=quiz_item)
        
        # 5. Update document status
        logger.info("Updating document status...")
        documents_table = dynamodb.Table(DOCUMENTS_TABLE)
        documents_table.update_item(
            Key={
                'courseId': course_id,
                'documentId': document_id
            },
            UpdateExpression='SET #status = :status, quizId = :quizId',
            ExpressionAttributeNames={
                '#status': 'status'
            },
            ExpressionAttributeValues={
                ':status': 'ready',
                ':quizId': quiz_id
            }
        )
        
        logger.info(f"Successfully processed document {document_id}")
        return ProcessingResult(status="success", quiz_id=quiz_id)
        
    except Exception as e:
        logger.error(f"Error processing document: {e}")
        
        # Update document status to failed
        try:
            documents_table = dynamodb.Table(DOCUMENTS_TABLE)
            documents_table.update_item(
                Key={
                    'courseId': course_id,
                    'documentId': document_id
                },
                UpdateExpression='SET #status = :status, processingError = :error',
                ExpressionAttributeNames={
                    '#status': 'status'
                },
                ExpressionAttributeValues={
                    ':status': 'failed',
                    ':error': str(e)
                }
            )
        except:
            pass
        
        return ProcessingResult(status="failed", error=str(e))

async def generate_quiz(text: str) -> List[QuizQuestion]:
    """Generate quiz questions using OpenAI API"""
    
    prompt = f"""Based on the following text, generate exactly 5 multiple choice questions in Italian.
Each question should test understanding of key concepts from the text.

IMPORTANT: Respond ONLY with a JSON array, no other text before or after.

The JSON must have this exact structure:
[
  {{
    "question": "La domanda in italiano?",
    "options": ["Opzione A", "Opzione B", "Opzione C", "Opzione D"],
    "correct_answer": 0
  }},
  {{
    "question": "Seconda domanda?",
    "options": ["Opzione A", "Opzione B", "Opzione C", "Opzione D"],
    "correct_answer": 2
  }}
]

Text to analyze:
{text}...

Remember: Generate exactly 5 questions. The correct_answer must be a number from 0 to 3."""

    try:
        client = get_openai_client()
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {
                    "role": "system",
                    "content": "You are a helpful assistant that generates educational multiple-choice questions. Always respond with valid JSON only, no additional text."
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            temperature=0.7,
            max_tokens=2000
        )
        
        # Get the response content
        response_text = response.choices[0].message.content
        logger.info(f"OpenAI raw response: {response_text[:200]}...")  # Log first 200 chars
        
        # Try to extract JSON from the response
        # Sometimes OpenAI adds text before/after the JSON
        json_match = re.search(r'\[\s*{.*}\s*\]', response_text, re.DOTALL)
        if json_match:
            json_text = json_match.group(0)
        else:
            json_text = response_text.strip()
        
        # Parse response
        quiz_data = json.loads(json_text)
        
        # Validate and convert to QuizQuestion objects
        questions = []
        for i, item in enumerate(quiz_data[:5]):  # Ensure max 5 questions
            try:
                question = QuizQuestion(
                    question=item.get('question', f'Domanda {i+1}'),
                    options=item.get('options', ['A', 'B', 'C', 'D'])[:4],
                    correct_answer=min(int(item.get('correct_answer', 0)), 3)
                )
                questions.append(question)
            except Exception as e:
                logger.error(f"Error parsing question {i}: {e}")
                continue
        
        # Se abbiamo meno di 5 domande, genera domande default aggiuntive
        while len(questions) < 5:
            questions.append(
                QuizQuestion(
                    question=f"Domanda {len(questions) + 1}: Qual è un concetto importante trattato nel documento?",
                    options=[
                        "Il documento tratta principalmente di storia",
                        "Il documento tratta principalmente di geografia", 
                        "Il documento tratta principalmente di scienze",
                        "Il documento tratta principalmente di letteratura"
                    ],
                    correct_answer=0
                )
            )
        
        logger.info(f"Generated {len(questions)} quiz questions")
        return questions
        
    except json.JSONDecodeError as e:
        logger.error(f"JSON decode error: {e}")
        logger.error(f"Response was: {response_text[:500]}...")
    except Exception as e:
        logger.error(f"Failed to generate quiz: {e}")
    
    # Return 5 default questions if generation fails
    return [
        QuizQuestion(
            question=f"Domanda {i+1}: Qual è un aspetto importante del documento?",
            options=[
                f"Prima opzione per domanda {i+1}",
                f"Seconda opzione per domanda {i+1}", 
                f"Terza opzione per domanda {i+1}",
                f"Quarta opzione per domanda {i+1}"
            ],
            correct_answer=0
        )
        for i in range(5)
    ]

# Run processing when container starts
@app.on_event("startup")
async def startup_event():
    # Start processing in background
    asyncio.create_task(process_and_shutdown())

async def process_and_shutdown():
    """Process document and shutdown after completion"""
    try:
        await asyncio.sleep(5)  # Give FastAPI time to start
        result = await process_document()
        logger.info(f"Processing complete: {result}")
    except Exception as e:
        logger.error(f"Processing failed: {e}")
    finally:
        # Give time for health checks before shutting down
        await asyncio.sleep(30)
        os._exit(0)

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)



PATH: /elearning-platform/src/ecs-container/requirements.txt

fastapi==0.104.1
uvicorn==0.24.0
boto3==1.29.7
openai==1.3.7
pydantic==2.5.0
python-multipart==0.0.6


PATH: /elearning-platform/src/ecs-container/build-and-push.sh

#!/bin/bash

# Script per build e push del container Docker

set -e

# Ottieni i dettagli da Terraform
# cd ../../terraform
# ECR_URL=$(terraform output -raw ecr_repository_url 2>/dev/null || echo "")
# cd ../src/ecs-container

ECR_URL="323395044516.dkr.ecr.us-east-1.amazonaws.com/elearning-dev-quiz-processor"

if [ -z "$ECR_URL" ]; then
    echo "Error: Could not get ECR repository URL from Terraform"
    exit 1
fi

# Extract region and registry from ECR URL
REGION=$(echo $ECR_URL | cut -d'.' -f4)
REGISTRY=$(echo $ECR_URL | cut -d'/' -f1)

echo "ECR Repository: $ECR_URL"
echo "Region: $REGION"

# Login to ECR
echo "Logging in to ECR..."
aws ecr get-login-password --region $REGION | docker login --username AWS --password-stdin $REGISTRY

# Build image
echo "Building Docker image..."
docker build -t quiz-processor .

# Tag image
echo "Tagging image..."
docker tag quiz-processor:latest $ECR_URL:latest

# Push image
echo "Pushing image to ECR..."
docker push $ECR_URL:latest

echo "Done! Image pushed to $ECR_URL:latest"



PATH: /elearning-platform/src/frontend/.dockerignore

node_modules
npm-debug.log
.git
.gitignore
README.md
.env
coverage
.DS_Store


PATH: /elearning-platform/src/frontend/.env

REACT_APP_AWS_REGION=us-east-1
REACT_APP_USER_POOL_ID=us-east-1_0Bpgy24wc
REACT_APP_USER_POOL_CLIENT_ID=6v75oj0coo1n2qmjrn7oki6t8o
REACT_APP_API_ENDPOINT=https://50m07h3cai.execute-api.us-east-1.amazonaws.com/dev


PATH: /elearning-platform/src/frontend/.gitignore

# Elastic Beanstalk Files
.elasticbeanstalk/*
!.elasticbeanstalk/*.cfg.yml
!.elasticbeanstalk/*.global.yml


PATH: /elearning-platform/src/frontend/deploy.sh

#!/bin/bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Check if EB CLI is installed
if ! command -v eb &> /dev/null; then
    echo -e "${RED}EB CLI not found. Please install it first.${NC}"
    echo "pip install awsebcli"
    exit 1
fi

# Check if .env file exists
if [ ! -f ".env.production" ]; then
    echo -e "${RED}.env file not found!${NC}"
    echo "Please copy .env.example to .env and configure it:"
    echo "cp .env.example .env"
    exit 1
fi

# Initialize EB CLI if not already done
if [ ! -d ".elasticbeanstalk" ]; then
    echo -e "${YELLOW}Initializing Elastic Beanstalk...${NC}"
    eb init -p "Docker running on 64bit Amazon Linux 2" elearning-dev-frontend --region us-east-1
fi

echo -e "${YELLOW}Installing dependencies...${NC}"
npm install

echo -e "${YELLOW}Building React app...${NC}"
npm run build

echo -e "${YELLOW}Creating deployment package...${NC}"
# Remove old zip if exists
rm -f deploy.zip
# Create new zip with necessary files
zip -r deploy.zip Dockerfile Dockerrun.aws.json nginx.conf build/ package.json -x "*.git*" "node_modules/*"

# Check if environment exists
# if ! eb list | grep -q "elearning-dev"; then
#     echo -e "${YELLOW}Creating new Elastic Beanstalk environment...${NC}"
#     eb create elearning-dev --instance-type t3.medium --envvars $(cat .env | grep -v '^#' | xargs | tr ' ' ',')
# else
#     echo -e "${YELLOW}Deploying to existing environment...${NC}"
#     eb deploy
# fi

# Using the existing environment created by Terraform
echo -e "${YELLOW}Deploying to existing environment...${NC}"
eb use elearning-dev-frontend-env
eb deploy


echo -e "${GREEN}Getting environment info...${NC}"
eb status

# Get the environment URL
ENV_URL=$(eb status | grep "CNAME:" | awk '{print $2}')
echo -e "${GREEN}Deployment complete!${NC}"
echo -e "${GREEN}Frontend URL: http://${ENV_URL}${NC}"
# echo ""
# echo -e "${YELLOW}Next steps:${NC}"
# echo "1. Update domain_name in terraform.tfvars with: ${ENV_URL}"
# echo "2. Run 'terraform apply' to update CORS settings"


PATH: /elearning-platform/src/frontend/Dockerfile

# Build stage
FROM node:18-alpine as build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Production stage
FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]


PATH: /elearning-platform/src/frontend/Dockerrun.aws.json

{
  "AWSEBDockerrunVersion": "1",
  "Ports": [
    {
      "ContainerPort": "80"
    }
  ],
  "Volumes": [],
  "Logging": "/var/log/nginx"
}


PATH: /elearning-platform/src/frontend/nginx.conf

server {
    listen 80;
    location / {
        root /usr/share/nginx/html;
        index index.html index.htm;
        try_files $uri $uri/ /index.html;
    }
    
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }
}


PATH: /elearning-platform/src/frontend/package.json

{
  "name": "elearning-platform",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@aws-amplify/ui-react": "^5.3.1",
    "aws-amplify": "^5.3.12",
    "axios": "^1.6.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.20.0",
    "react-query": "^3.39.3",
    "@emotion/react": "^11.11.1",
    "@emotion/styled": "^11.11.0",
    "@mui/material": "^5.14.18",
    "@mui/icons-material": "^5.14.18"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "react-scripts": "5.0.1"
  }
}


PATH: /elearning-platform/src/frontend/.elasticbeanstalk/config.yml

branch-defaults:
  default:
    environment: null
    group_suffix: null
global:
  application_name: elearning-platform
  branch: null
  default_ec2_keyname: null
  default_platform: Docker running on 64bit Amazon Linux 2
  default_region: us-east-1
  include_git_submodules: true
  instance_profile: null
  platform_name: null
  platform_version: null
  profile: null
  repository: null
  sc: null
  workspace_type: Application



PATH: /elearning-platform/src/frontend/public/index.html

<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="E-Learning Platform" />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"
    />
    <title>E-Learning Platform</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>



PATH: /elearning-platform/src/frontend/src/index.js

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import { Amplify } from 'aws-amplify';
import config from './aws-config';

// Configure Amplify
Amplify.configure(config);

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


PATH: /elearning-platform/src/frontend/src/index.css

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

* {
  box-sizing: border-box;
}



PATH: /elearning-platform/src/frontend/src/aws-config.js

const config = {
  Auth: {
    region: process.env.REACT_APP_AWS_REGION || 'us-east-1',
    userPoolId: process.env.REACT_APP_USER_POOL_ID,
    userPoolWebClientId: process.env.REACT_APP_USER_POOL_CLIENT_ID,
  },
  API: {
    endpoints: [
      {
        name: 'elearning-api',
        endpoint: process.env.REACT_APP_API_ENDPOINT,
      },
    ],
  },
};

export default config;


PATH: /elearning-platform/src/frontend/src/App.js

import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { QueryClient, QueryClientProvider } from 'react-query';

// Components
import Login from './components/auth/Login';
import Register from './components/auth/Register';
import ForgotPassword from './components/auth/ForgotPassword';
import TeacherDashboard from './components/teacher/TeacherDashboard';
import StudentDashboard from './components/student/StudentDashboard';
import PrivateRoute from './components/common/PrivateRoute';

// Hooks
import { AuthProvider } from './hooks/useAuth';

const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
    },
    secondary: {
      main: '#dc004e',
    },
  },
});

const queryClient = new QueryClient();

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        <AuthProvider>
          <Router>
            <Routes>
              <Route path="/login" element={<Login />} />
              <Route path="/register" element={<Register />} />
              <Route path="/forgot-password" element={<ForgotPassword />} />
              
              <Route path="/teacher/*" element={
                <PrivateRoute requiredRole="Docenti">
                  <TeacherDashboard />
                </PrivateRoute>
              } />
              
              <Route path="/student/*" element={
                <PrivateRoute requiredRole="Studenti">
                  <StudentDashboard />
                </PrivateRoute>
              } />
              
              <Route path="/" element={<Navigate to="/login" replace />} />
            </Routes>
          </Router>
        </AuthProvider>
      </ThemeProvider>
    </QueryClientProvider>
  );
}

export default App;


PATH: /elearning-platform/src/frontend/src/components/auth/Register.jsx

import React, { useState } from 'react';
import {
  Container,
  Paper,
  TextField,
  Button,
  Typography,
  Box,
  Alert,
  Link,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
} from '@mui/material';
import { useNavigate, Link as RouterLink } from 'react-router-dom';
import { authService } from '../../services/auth';

const Register = () => {
  const navigate = useNavigate();
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    confirmPassword: '',
    name: '',
    familyName: '',
    role: 'studente',
  });
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const [confirmDialog, setConfirmDialog] = useState(false);
  const [confirmCode, setConfirmCode] = useState('');

  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');

    if (formData.password !== formData.confirmPassword) {
      setError('Le password non corrispondono');
      return;
    }

    setLoading(true);

    try {
      await authService.signUp(
        formData.email,
        formData.password,
        formData.name,
        formData.familyName,
        formData.role
      );
      setConfirmDialog(true);
    } catch (error) {
      setError(error.message || 'Errore durante la registrazione');
    } finally {
      setLoading(false);
    }
  };

  const handleConfirm = async () => {
    setError('');
    setLoading(true);

    try {
      await authService.confirmSignUp(formData.email, confirmCode);
      navigate('/login');
    } catch (error) {
      setError(error.message || 'Codice non valido');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box
        sx={{
          marginTop: 8,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
        }}
      >
        <Paper elevation={3} sx={{ padding: 4, width: '100%' }}>
          <Typography component="h1" variant="h5" align="center">
            Registrazione
          </Typography>

          {error && (
            <Alert severity="error" sx={{ mt: 2 }}>
              {error}
            </Alert>
          )}

          <Box component="form" onSubmit={handleSubmit} sx={{ mt: 1 }}>
            <TextField
              margin="normal"
              required
              fullWidth
              name="name"
              label="Nome"
              autoFocus
              value={formData.name}
              onChange={handleChange}
            />
            
            <TextField
              margin="normal"
              required
              fullWidth
              name="familyName"
              label="Cognome"
              value={formData.familyName}
              onChange={handleChange}
            />
            
            <TextField
              margin="normal"
              required
              fullWidth
              name="email"
              label="Email"
              type="email"
              value={formData.email}
              onChange={handleChange}
            />
            
            <FormControl fullWidth margin="normal">
              <InputLabel>Ruolo</InputLabel>
              <Select
                name="role"
                value={formData.role}
                onChange={handleChange}
                label="Ruolo"
              >
                <MenuItem value="studente">Studente</MenuItem>
                <MenuItem value="docente">Docente</MenuItem>
              </Select>
            </FormControl>
            
            <TextField
              margin="normal"
              required
              fullWidth
              name="password"
              label="Password"
              type="password"
              value={formData.password}
              onChange={handleChange}
              helperText="Minimo 8 caratteri, con maiuscole, minuscole, numeri e simboli"
            />
            
            <TextField
              margin="normal"
              required
              fullWidth
              name="confirmPassword"
              label="Conferma Password"
              type="password"
              value={formData.confirmPassword}
              onChange={handleChange}
            />
            
            <Button
              type="submit"
              fullWidth
              variant="contained"
              sx={{ mt: 3, mb: 2 }}
              disabled={loading}
            >
              {loading ? 'Registrazione in corso...' : 'Registrati'}
            </Button>
            
            <Box sx={{ textAlign: 'center' }}>
              <Link component={RouterLink} to="/login" variant="body2">
                Hai già un account? Accedi
              </Link>
            </Box>
          </Box>
        </Paper>
      </Box>

      {/* Confirmation Dialog */}
      <Dialog open={confirmDialog} onClose={() => {}}>
        <DialogTitle>Conferma Email</DialogTitle>
        <DialogContent>
          <DialogContentText>
            Abbiamo inviato un codice di conferma a {formData.email}.
            Inserisci il codice per completare la registrazione.
          </DialogContentText>
          <TextField
            autoFocus
            margin="dense"
            label="Codice di conferma"
            fullWidth
            variant="outlined"
            value={confirmCode}
            onChange={(e) => setConfirmCode(e.target.value)}
          />
          {error && (
            <Alert severity="error" sx={{ mt: 2 }}>
              {error}
            </Alert>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleConfirm} disabled={loading}>
            Conferma
          </Button>
        </DialogActions>
      </Dialog>
    </Container>
  );
};

export default Register;



PATH: /elearning-platform/src/frontend/src/components/auth/Login.jsx

import React, { useState } from 'react';
import {
  Container,
  Paper,
  TextField,
  Button,
  Typography,
  Box,
  Alert,
  Link,
} from '@mui/material';
import { useNavigate, Link as RouterLink } from 'react-router-dom';
import { useAuth } from '../../hooks/useAuth';

const Login = () => {
  const navigate = useNavigate();
  const { signIn } = useAuth();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setLoading(true);

    try {
      const user = await signIn(email, password);
      
      // Redirect based on user role
      if (user.isTeacher) {
        navigate('/teacher');
      } else if (user.isStudent) {
        navigate('/student');
      }
    } catch (error) {
      setError(error.message || 'Errore durante il login');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box
        sx={{
          marginTop: 8,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
        }}
      >
        <Paper elevation={3} sx={{ padding: 4, width: '100%' }}>
          <Typography component="h1" variant="h5" align="center">
            E-Learning Platform
          </Typography>
          
          <Typography component="h2" variant="h6" align="center" sx={{ mt: 2 }}>
            Accedi
          </Typography>

          {error && (
            <Alert severity="error" sx={{ mt: 2 }}>
              {error}
            </Alert>
          )}

          <Box component="form" onSubmit={handleSubmit} sx={{ mt: 1 }}>
            <TextField
              margin="normal"
              required
              fullWidth
              id="email"
              label="Email"
              name="email"
              autoComplete="email"
              autoFocus
              value={email}
              onChange={(e) => setEmail(e.target.value)}
            />
            
            <TextField
              margin="normal"
              required
              fullWidth
              name="password"
              label="Password"
              type="password"
              id="password"
              autoComplete="current-password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
            
            <Button
              type="submit"
              fullWidth
              variant="contained"
              sx={{ mt: 3, mb: 2 }}
              disabled={loading}
            >
              {loading ? 'Accesso in corso...' : 'Accedi'}
            </Button>
            
            <Box sx={{ textAlign: 'center' }}>
              <Link component={RouterLink} to="/forgot-password" variant="body2">
                Password dimenticata?
              </Link>
            </Box>
            
            <Box sx={{ textAlign: 'center', mt: 2 }}>
              <Link component={RouterLink} to="/register" variant="body2">
                Non hai un account? Registrati
              </Link>
            </Box>
          </Box>
        </Paper>
      </Box>
    </Container>
  );
};

export default Login;



PATH: /elearning-platform/src/frontend/src/components/auth/ForgotPassword.jsx

import React, { useState } from 'react';
import {
  Container,
  Paper,
  TextField,
  Button,
  Typography,
  Box,
  Alert,
  Link,
  Stepper,
  Step,
  StepLabel,
} from '@mui/material';
import { useNavigate, Link as RouterLink } from 'react-router-dom';
import { authService } from '../../services/auth';

const ForgotPassword = () => {
  const navigate = useNavigate();
  const [activeStep, setActiveStep] = useState(0);
  const [email, setEmail] = useState('');
  const [code, setCode] = useState('');
  const [newPassword, setNewPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const steps = ['Inserisci email', 'Inserisci codice', 'Nuova password'];

  const handleEmailSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setLoading(true);

    try {
      await authService.forgotPassword(email);
      setActiveStep(1);
    } catch (error) {
      setError(error.message || 'Errore durante l\'invio del codice');
    } finally {
      setLoading(false);
    }
  };

  const handleResetPassword = async (e) => {
    e.preventDefault();
    setError('');

    if (newPassword !== confirmPassword) {
      setError('Le password non corrispondono');
      return;
    }

    setLoading(true);

    try {
      await authService.forgotPasswordSubmit(email, code, newPassword);
      setActiveStep(2);
      setTimeout(() => {
        navigate('/login');
      }, 2000);
    } catch (error) {
      setError(error.message || 'Errore durante il reset della password');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box
        sx={{
          marginTop: 8,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
        }}
      >
        <Paper elevation={3} sx={{ padding: 4, width: '100%' }}>
          <Typography component="h1" variant="h5" align="center">
            Recupera Password
          </Typography>

          <Stepper activeStep={activeStep} sx={{ mt: 3, mb: 3 }}>
            {steps.map((label) => (
              <Step key={label}>
                <StepLabel>{label}</StepLabel>
              </Step>
            ))}
          </Stepper>

          {error && (
            <Alert severity="error" sx={{ mb: 2 }}>
              {error}
            </Alert>
          )}

          {activeStep === 0 && (
            <Box component="form" onSubmit={handleEmailSubmit}>
              <TextField
                margin="normal"
                required
                fullWidth
                label="Email"
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                autoFocus
              />
              
              <Button
                type="submit"
                fullWidth
                variant="contained"
                sx={{ mt: 3, mb: 2 }}
                disabled={loading}
              >
                {loading ? 'Invio in corso...' : 'Invia codice'}
              </Button>
            </Box>
          )}

          {activeStep === 1 && (
            <Box component="form" onSubmit={handleResetPassword}>
              <TextField
                margin="normal"
                required
                fullWidth
                label="Codice di verifica"
                value={code}
                onChange={(e) => setCode(e.target.value)}
                autoFocus
              />
              
              <TextField
                margin="normal"
                required
                fullWidth
                label="Nuova password"
                type="password"
                value={newPassword}
                onChange={(e) => setNewPassword(e.target.value)}
              />
              
              <TextField
                margin="normal"
                required
                fullWidth
                label="Conferma password"
                type="password"
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
              />
              
              <Button
                type="submit"
                fullWidth
                variant="contained"
                sx={{ mt: 3, mb: 2 }}
                disabled={loading}
              >
                {loading ? 'Reset in corso...' : 'Reimposta password'}
              </Button>
            </Box>
          )}

          {activeStep === 2 && (
            <Alert severity="success">
              Password reimpostata con successo! Reindirizzamento al login...
            </Alert>
          )}

          <Box sx={{ textAlign: 'center', mt: 2 }}>
            <Link component={RouterLink} to="/login" variant="body2">
              Torna al login
            </Link>
          </Box>
        </Paper>
      </Box>
    </Container>
  );
};

export default ForgotPassword;



PATH: /elearning-platform/src/frontend/src/components/common/Header.jsx

import React from 'react';
import {
  AppBar,
  Toolbar,
  Typography,
  Box,
  IconButton,
  Menu,
  MenuItem,
} from '@mui/material';
import { AccountCircle } from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../hooks/useAuth';

const Header = ({ title }) => {
  const navigate = useNavigate();
  const { user, signOut } = useAuth();
  const [anchorEl, setAnchorEl] = React.useState(null);

  const handleMenu = (event) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  const handleLogout = async () => {
    await signOut();
    navigate('/login');
  };

  return (
    <AppBar position="static">
      <Toolbar>
        <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
          {title}
        </Typography>
        
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <Typography variant="body2" sx={{ mr: 2 }}>
            {user?.name} {user?.familyName}
          </Typography>
          
          <IconButton
            size="large"
            aria-label="account of current user"
            aria-controls="menu-appbar"
            aria-haspopup="true"
            onClick={handleMenu}
            color="inherit"
          >
            <AccountCircle />
          </IconButton>
          
          <Menu
            id="menu-appbar"
            anchorEl={anchorEl}
            anchorOrigin={{
              vertical: 'top',
              horizontal: 'right',
            }}
            keepMounted
            transformOrigin={{
              vertical: 'top',
              horizontal: 'right',
            }}
            open={Boolean(anchorEl)}
            onClose={handleClose}
          >
            <MenuItem onClick={handleLogout}>Logout</MenuItem>
          </Menu>
        </Box>
      </Toolbar>
    </AppBar>
  );
};

export default Header;



PATH: /elearning-platform/src/frontend/src/components/common/LoadingSpinner.jsx

import React from 'react';
import { Box, CircularProgress } from '@mui/material';

const LoadingSpinner = () => {
  return (
    <Box
      display="flex"
      justifyContent="center"
      alignItems="center"
      minHeight="100vh"
    >
      <CircularProgress />
    </Box>
  );
};

export default LoadingSpinner;



PATH: /elearning-platform/src/frontend/src/components/common/PrivateRoute.jsx

import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../../hooks/useAuth';
import LoadingSpinner from './LoadingSpinner';

const PrivateRoute = ({ children, requiredRole }) => {
  const { user, loading } = useAuth();

  if (loading) {
    return <LoadingSpinner />;
  }

  if (!user) {
    return <Navigate to="/login" replace />;
  }

  if (requiredRole && !user.groups.includes(requiredRole)) {
    return <Navigate to="/login" replace />;
  }

  return children;
};

export default PrivateRoute;



PATH: /elearning-platform/src/frontend/src/components/student/StudentDashboard.jsx

import React from 'react';
import { Routes, Route, useNavigate } from 'react-router-dom';
import {
  Box,
  Drawer,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  ListItemButton,
  Toolbar,
} from '@mui/material';
import {
  School as SchoolIcon,
  Assignment as AssignmentIcon,
  Quiz as QuizIcon,
  History as HistoryIcon,
} from '@mui/icons-material';
import Header from '../common/Header';
import CourseList from './CourseList';
import CourseView from './CourseView';
import QuizRunner from './QuizRunner';
import ResultsHistory from './ResultsHistory';

const drawerWidth = 240;

const StudentDashboard = () => {
  const navigate = useNavigate();

  const menuItems = [
    { text: 'Corsi disponibili', icon: <SchoolIcon />, path: '/student' },
    { text: 'I miei corsi', icon: <AssignmentIcon />, path: '/student/my-courses' },
    { text: 'Quiz', icon: <QuizIcon />, path: '/student/quizzes' },
    { text: 'Risultati', icon: <HistoryIcon />, path: '/student/results' },
  ];

  return (
    <Box sx={{ display: 'flex' }}>
      <Header title="Dashboard Studente" />
      
      <Drawer
        variant="permanent"
        sx={{
          width: drawerWidth,
          flexShrink: 0,
          '& .MuiDrawer-paper': {
            width: drawerWidth,
            boxSizing: 'border-box',
          },
        }}
      >
        <Toolbar />
        <Box sx={{ overflow: 'auto' }}>
          <List>
            {menuItems.map((item) => (
              <ListItem key={item.text} disablePadding>
                <ListItemButton onClick={() => navigate(item.path)}>
                  <ListItemIcon>{item.icon}</ListItemIcon>
                  <ListItemText primary={item.text} />
                </ListItemButton>
              </ListItem>
            ))}
          </List>
        </Box>
      </Drawer>
      
      <Box component="main" sx={{ flexGrow: 1, p: 3 }}>
        <Toolbar />
        <Routes>
          <Route path="/" element={<CourseList showAll={true} />} />
          <Route path="/my-courses" element={<CourseList showAll={false} />} />
          <Route path="/course/:courseId" element={<CourseView />} />
          <Route path="/quiz/:courseId/:documentId" element={<QuizRunner />} />
          <Route path="/quizzes" element={<CourseList showAll={false} quizMode={true} />} />
          <Route path="/results" element={<ResultsHistory />} />
        </Routes>
      </Box>
    </Box>
  );
};

export default StudentDashboard;



PATH: /elearning-platform/src/frontend/src/components/student/ResultsHistory.jsx

import React, { useState, useEffect } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Chip,
  Grid,
  Alert,
  LinearProgress,
  List,
  ListItem,
  ListItemText,
  Divider,
} from '@mui/material';
import {
  ExpandMore as ExpandMoreIcon,
  CheckCircle as CorrectIcon,
  Cancel as WrongIcon,
  Description as DocumentIcon,
} from '@mui/icons-material';
import { resultsAPI } from '../../services/api';
import LoadingSpinner from '../common/LoadingSpinner';

const ResultsHistory = () => {
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [expanded, setExpanded] = useState(false);

  // eslint-disable-next-line react-hooks/exhaustive-deps
  useEffect(() => {
    fetchResults();
  }, []);

  const fetchResults = async () => {
    setLoading(true);
    setError('');
    
    try {
      const response = await resultsAPI.list();
      setResults(response.data.results);
    } catch (error) {
      setError('Errore nel caricamento dei risultati');
      console.error('Error fetching results:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleAccordionChange = (panel) => (event, isExpanded) => {
    setExpanded(isExpanded ? panel : false);
  };

  if (loading) return <LoadingSpinner />;

  const summary = results.length > 0 ? {
    totalQuizzes: results.length,
    averageScore: Math.round(
      results.reduce((sum, r) => sum + r.averageScore, 0) / results.length
    ),
    totalAttempts: results.reduce((sum, r) => sum + r.totalAttempts, 0),
  } : null;

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        I Miei Risultati
      </Typography>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}

      {/* Summary Card */}
      {summary && (
        <Card sx={{ mb: 3 }}>
          <CardContent>
            <Typography variant="h6" gutterBottom>
              Riepilogo
            </Typography>
            <Grid container spacing={3}>
              <Grid item xs={12} sm={4}>
                <Typography variant="h3" color="primary">
                  {summary.totalQuizzes}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Quiz Completati
                </Typography>
              </Grid>
              <Grid item xs={12} sm={4}>
                <Typography variant="h3" color="primary">
                  {summary.averageScore}%
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Media Voti
                </Typography>
              </Grid>
              <Grid item xs={12} sm={4}>
                <Typography variant="h3" color="primary">
                  {summary.totalAttempts}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Tentativi Totali
                </Typography>
              </Grid>
            </Grid>
          </CardContent>
        </Card>
      )}

      {/* Results List */}
      {results.length === 0 ? (
        <Card>
          <CardContent>
            <Typography variant="body2" color="text.secondary" textAlign="center">
              Non hai ancora completato nessun quiz
            </Typography>
          </CardContent>
        </Card>
      ) : (
        results.map((quizResult, index) => (
          <Accordion
            key={quizResult.quizId}
            expanded={expanded === `panel${index}`}
            onChange={handleAccordionChange(`panel${index}`)}
            sx={{ mb: 1 }}
          >
            <AccordionSummary expandIcon={<ExpandMoreIcon />}>
              <Box sx={{ display: 'flex', alignItems: 'center', width: '100%' }}>
                <DocumentIcon sx={{ mr: 2 }} />
                <Box sx={{ flexGrow: 1 }}>
                  <Typography variant="h6">
                    Quiz #{index + 1}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    Miglior voto: {quizResult.bestScore}% | 
                    Tentativi: {quizResult.totalAttempts}
                  </Typography>
                </Box>
                <Chip
                  label={`${quizResult.bestScore}%`}
                  color={quizResult.bestScore >= 60 ? 'success' : 'error'}
                  sx={{ mr: 2 }}
                />
              </Box>
            </AccordionSummary>
            
            <AccordionDetails>
              {/* Last Attempt Details */}
              <Typography variant="subtitle1" gutterBottom>
                Ultimo Tentativo
              </Typography>
              <Typography variant="body2" color="text.secondary" gutterBottom>
                Data: {new Date(quizResult.lastAttempt.completedAt).toLocaleString()}
              </Typography>
              <Typography variant="body2" gutterBottom>
                Risultato: {quizResult.lastAttempt.correctAnswers} su {quizResult.lastAttempt.totalQuestions} 
                ({quizResult.lastAttempt.score}%)
              </Typography>
              
              <Divider sx={{ my: 2 }} />
              
              {/* Questions Review */}
              <Typography variant="subtitle1" gutterBottom>
                Revisione Domande
              </Typography>
              <List>
                {quizResult.lastAttempt.detailedResults.map((question, qIndex) => (
                  <React.Fragment key={question.questionId}>
                    <ListItem alignItems="flex-start">
                      <ListItemText
                        primary={
                          <Box sx={{ display: 'flex', alignItems: 'center' }}>
                            {question.isCorrect ? (
                              <CorrectIcon color="success" sx={{ mr: 1 }} />
                            ) : (
                              <WrongIcon color="error" sx={{ mr: 1 }} />
                            )}
                            <Typography variant="body1">
                              Domanda {qIndex + 1}: {question.question}
                            </Typography>
                          </Box>
                        }
                        secondary={
                          <Box sx={{ mt: 1 }}>
                            <Typography variant="body2">
                              La tua risposta: {question.studentAnswer !== null ? 
                                `Opzione ${question.studentAnswer + 1}` : 'Non risposto'}
                            </Typography>
                            <Typography variant="body2" color="success.main">
                              Risposta corretta: Opzione {question.correctAnswer + 1}
                            </Typography>
                          </Box>
                        }
                      />
                    </ListItem>
                    {qIndex < quizResult.lastAttempt.detailedResults.length - 1 && <Divider />}
                  </React.Fragment>
                ))}
              </List>
              
              {/* Progress Bar */}
              <Box sx={{ mt: 3 }}>
                <Typography variant="body2" gutterBottom>
                  Progresso Complessivo
                </Typography>
                <LinearProgress 
                  variant="determinate" 
                  value={quizResult.lastAttempt.score} 
                  color={quizResult.lastAttempt.score >= 60 ? 'success' : 'error'}
                  sx={{ height: 10, borderRadius: 5 }}
                />
              </Box>
            </AccordionDetails>
          </Accordion>
        ))
      )}
    </Box>
  );
};

export default ResultsHistory;



PATH: /elearning-platform/src/frontend/src/components/student/QuizRunner.jsx

import React, { useState, useEffect } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  Button,
  Radio,
  RadioGroup,
  FormControlLabel,
  FormControl,
  Alert,
  LinearProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  Chip,
} from '@mui/material';
import {
  CheckCircle as CorrectIcon,
  Cancel as WrongIcon,
} from '@mui/icons-material';
import { useParams, useNavigate } from 'react-router-dom';
import { quizAPI } from '../../services/api';
import LoadingSpinner from '../common/LoadingSpinner';

const QuizRunner = () => {
  const { courseId, documentId } = useParams();
  const navigate = useNavigate();
  
  const [quiz, setQuiz] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [currentQuestion, setCurrentQuestion] = useState(0);
  const [answers, setAnswers] = useState({});
  const [submitted, setSubmitted] = useState(false);
  const [results, setResults] = useState(null);
  const [showResults, setShowResults] = useState(false);

  // eslint-disable-next-line react-hooks/exhaustive-deps
  useEffect(() => {
    fetchQuiz();
  }, [courseId, documentId]);

  const fetchQuiz = async () => {
    setLoading(true);
    setError('');
    
    try {
      const response = await quizAPI.get(courseId, documentId);
      setQuiz(response.data.quiz);
      
      // Initialize answers object
      const initialAnswers = {};
      response.data.quiz.questions.forEach(q => {
        initialAnswers[q.questionId] = null;
      });
      setAnswers(initialAnswers);
    } catch (error) {
      setError('Errore nel caricamento del quiz');
      console.error('Error fetching quiz:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleAnswerChange = (questionId, value) => {
    setAnswers({
      ...answers,
      [questionId]: parseInt(value)
    });
  };

  const handleNext = () => {
    if (currentQuestion < quiz.questions.length - 1) {
      setCurrentQuestion(currentQuestion + 1);
    }
  };

  const handlePrevious = () => {
    if (currentQuestion > 0) {
      setCurrentQuestion(currentQuestion - 1);
    }
  };

  const handleSubmit = async () => {
    // Check if all questions are answered
    const unanswered = Object.values(answers).filter(a => a === null).length;
    if (unanswered > 0) {
      setError(`Ci sono ancora ${unanswered} domande senza risposta`);
      return;
    }

    setSubmitted(true);
    setError('');
    
    try {
      const response = await quizAPI.submit(courseId, documentId, {
        quizId: quiz.quizId,
        answers: answers
      });
      
      setResults(response.data.result);
      setShowResults(true);
    } catch (error) {
      setError('Errore durante l\'invio del quiz');
      console.error('Error submitting quiz:', error);
      setSubmitted(false);
    }
  };

  if (loading) return <LoadingSpinner />;
  if (!quiz) return <Alert severity="error">Quiz non trovato</Alert>;

  const question = quiz.questions[currentQuestion];
  const progress = ((currentQuestion + 1) / quiz.questions.length) * 100;

  return (
    <Box>
      <Card sx={{ mb: 3 }}>
        <CardContent>
          <Typography variant="h4" gutterBottom>
            Quiz: {quiz.documentName}
          </Typography>
          
          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
            <Box sx={{ width: '100%', mr: 1 }}>
              <LinearProgress variant="determinate" value={progress} />
            </Box>
            <Box sx={{ minWidth: 100 }}>
              <Typography variant="body2" color="text.secondary">
                Domanda {currentQuestion + 1} di {quiz.questions.length}
              </Typography>
            </Box>
          </Box>
        </CardContent>
      </Card>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}

      {/* Question Card */}
      <Card>
        <CardContent>
          <Typography variant="h6" gutterBottom>
            {question.question}
          </Typography>
          
          <FormControl component="fieldset" sx={{ mt: 2, width: '100%' }}>
            <RadioGroup
              value={answers[question.questionId] !== null ? answers[question.questionId].toString() : ''}
              onChange={(e) => handleAnswerChange(question.questionId, e.target.value)}
            >
              {question.options.map((option, index) => (
                <FormControlLabel
                  key={index}
                  value={index.toString()}
                  control={<Radio />}
                  label={option}
                  disabled={submitted}
                  sx={{ mb: 1 }}
                />
              ))}
            </RadioGroup>
          </FormControl>
          
          {/* Navigation Buttons */}
          <Box sx={{ mt: 4, display: 'flex', justifyContent: 'space-between' }}>
            <Button
              onClick={handlePrevious}
              disabled={currentQuestion === 0 || submitted}
            >
              Precedente
            </Button>
            
            <Box>
              {currentQuestion < quiz.questions.length - 1 ? (
                <Button
                  variant="contained"
                  onClick={handleNext}
                  disabled={answers[question.questionId] === null || submitted}
                >
                  Successiva
                </Button>
              ) : (
                <Button
                  variant="contained"
                  color="success"
                  onClick={handleSubmit}
                  disabled={submitted}
                >
                  {submitted ? 'Invio in corso...' : 'Invia Quiz'}
                </Button>
              )}
            </Box>
          </Box>
        </CardContent>
      </Card>

      {/* Results Dialog */}
      <Dialog 
        open={showResults} 
        onClose={() => navigate(`/student/results`)}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle>
          Risultati Quiz
        </DialogTitle>
        <DialogContent>
          <Box textAlign="center" py={2}>
            <Typography variant="h2" color="primary" gutterBottom>
              {results?.score}%
            </Typography>
            
            <Typography variant="h6" gutterBottom>
              Risposte corrette: {results?.correctAnswers} su {results?.totalQuestions}
            </Typography>
            
            {results?.score >= 60 ? (
              <Chip
                icon={<CorrectIcon />}
                label="Quiz Superato!"
                color="success"
                sx={{ mt: 2 }}
              />
            ) : (
              <Chip
                icon={<WrongIcon />}
                label="Quiz Non Superato"
                color="error"
                sx={{ mt: 2 }}
              />
            )}
          </Box>
          
          <DialogContentText sx={{ mt: 2 }}>
            Il quiz è stato completato e salvato. Puoi rivedere le tue risposte 
            e quelle corrette nella sezione "Risultati".
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => navigate(`/student/course/${courseId}`)}>
            Torna al Corso
          </Button>
          <Button 
            variant="contained" 
            onClick={() => navigate(`/student/results`)}
          >
            Vedi Dettagli
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default QuizRunner;



PATH: /elearning-platform/src/frontend/src/components/student/CourseView.jsx

import React, { useState, useEffect } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  Button,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  IconButton,
  Chip,
  Alert,
  Breadcrumbs,
  Link,
  Divider,
} from '@mui/material';
import {
  Download as DownloadIcon,
  Quiz as QuizIcon,
  PictureAsPdf as PdfIcon,
  NavigateNext as NavigateNextIcon,
} from '@mui/icons-material';
import { useParams, useNavigate, useLocation } from 'react-router-dom';
import { documentAPI, courseAPI } from '../../services/api';
import LoadingSpinner from '../common/LoadingSpinner';

const CourseView = () => {
  const { courseId } = useParams();
  const navigate = useNavigate();
  const location = useLocation();
  const quizMode = new URLSearchParams(location.search).get('quizMode') === 'true';
  
  const [course, setCourse] = useState(null);
  const [documents, setDocuments] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  // eslint-disable-next-line react-hooks/exhaustive-deps
  useEffect(() => {
    fetchCourseData();
  }, [courseId]);

  const fetchCourseData = async () => {
    setLoading(true);
    setError('');
    
    try {
      // Fetch course details
      const courseResponse = await courseAPI.get(courseId);
      setCourse(courseResponse.data.course);
      
      // Fetch documents
      const docsResponse = await documentAPI.list(courseId);
      setDocuments(docsResponse.data.documents);
    } catch (error) {
      setError('Errore nel caricamento dei dati del corso');
      console.error('Error fetching course data:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleDownload = async (document) => {
    try {
      const response = await documentAPI.getDownloadUrl(courseId, document.documentId);
      window.open(response.data.downloadUrl, '_blank');
    } catch (error) {
      setError('Errore durante il download');
      console.error('Error downloading:', error);
    }
  };

  const handleQuizClick = (document) => {
    navigate(`/student/quiz/${courseId}/${document.documentId}`);
  };

  if (loading) return <LoadingSpinner />;

  const documentsWithQuiz = documents.filter(doc => doc.quizId && doc.status === 'ready');

  return (
    <Box>
      {/* Breadcrumbs */}
      <Breadcrumbs 
        separator={<NavigateNextIcon fontSize="small" />} 
        sx={{ mb: 3 }}
      >
        <Link 
          component="button"
          variant="body1"
          onClick={() => navigate('/student')}
          underline="hover"
          color="inherit"
        >
          Dashboard
        </Link>
        <Link
          component="button"
          variant="body1"
          onClick={() => navigate(quizMode ? '/student/quizzes' : '/student/my-courses')}
          underline="hover"
          color="inherit"
        >
          {quizMode ? 'I Miei Quiz' : 'I Miei Corsi'}
        </Link>
        <Typography color="text.primary">{course?.name}</Typography>
      </Breadcrumbs>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}

      {/* Course Info */}
      <Card sx={{ mb: 3 }}>
        <CardContent>
          <Typography variant="h4" gutterBottom>
            {course?.name}
          </Typography>
          <Typography variant="body1" color="text.secondary" paragraph>
            {course?.description}
          </Typography>
          <Typography variant="body2">
            <strong>Docente:</strong> {course?.teacherEmail}
          </Typography>
        </CardContent>
      </Card>

      {/* Documents/Quiz List */}
      <Card>
        <CardContent>
          <Typography variant="h6" gutterBottom>
            {quizMode ? 'Quiz Disponibili' : 'Documenti del Corso'}
          </Typography>
          
          <Divider sx={{ mb: 2 }} />
          
          {quizMode ? (
            // Quiz Mode - Show only documents with quiz
            documentsWithQuiz.length === 0 ? (
              <Typography variant="body2" color="text.secondary" textAlign="center">
                Nessun quiz disponibile per questo corso
              </Typography>
            ) : (
              <List>
                {documentsWithQuiz.map((doc) => (
                  <React.Fragment key={doc.documentId}>
                    <ListItem>
                      <QuizIcon sx={{ mr: 2, color: 'primary.main' }} />
                      <ListItemText
                        primary={`Quiz: ${doc.name}`}
                        secondary={`Documento caricato: ${new Date(doc.uploadedAt).toLocaleDateString()}`}
                      />
                      <ListItemSecondaryAction>
                        <Button
                          variant="contained"
                          startIcon={<QuizIcon />}
                          onClick={() => handleQuizClick(doc)}
                        >
                          Inizia Quiz
                        </Button>
                      </ListItemSecondaryAction>
                    </ListItem>
                    <Divider />
                  </React.Fragment>
                ))}
              </List>
            )
          ) : (
            // Document Mode - Show all documents
            documents.length === 0 ? (
              <Typography variant="body2" color="text.secondary" textAlign="center">
                Nessun documento disponibile
              </Typography>
            ) : (
              <List>
                {documents.map((doc) => (
                  <React.Fragment key={doc.documentId}>
                    <ListItem>
                      <PdfIcon sx={{ mr: 2, color: 'error.main' }} />
                      <ListItemText
                        primary={doc.name}
                        secondary={
                          <Box>
                            <Typography variant="caption">
                              Caricato: {new Date(doc.uploadedAt).toLocaleDateString()}
                            </Typography>
                            {doc.quizId && (
                              <Chip
                                icon={<QuizIcon />}
                                label="Quiz disponibile"
                                size="small"
                                color="primary"
                                sx={{ ml: 2 }}
                              />
                            )}
                          </Box>
                        }
                      />
                      <ListItemSecondaryAction>
                        <IconButton
                          edge="end"
                          onClick={() => handleDownload(doc)}
                          sx={{ mr: 1 }}
                        >
                          <DownloadIcon />
                        </IconButton>
                        {doc.quizId && (
                          <Button
                            size="small"
                            variant="outlined"
                            startIcon={<QuizIcon />}
                            onClick={() => handleQuizClick(doc)}
                          >
                            Quiz
                          </Button>
                        )}
                      </ListItemSecondaryAction>
                    </ListItem>
                    <Divider />
                  </React.Fragment>
                ))}
              </List>
            )
          )}
        </CardContent>
      </Card>
    </Box>
  );
};

export default CourseView;



PATH: /elearning-platform/src/frontend/src/components/student/CourseList.jsx

import React, { useState } from 'react';
import {
  Box,
  Card,
  CardContent,
  CardActions,
  Grid,
  Typography,
  Button,
  Chip,
  Alert,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
} from '@mui/material';
import {
  School as SchoolIcon,
  Login as EnrollIcon,
  CheckCircle as ApprovedIcon,
  HourglassEmpty as PendingIcon,
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import { useCourses } from '../../hooks/useCourses';
import { enrollmentAPI } from '../../services/api';
import LoadingSpinner from '../common/LoadingSpinner';

const CourseList = ({ showAll = true, quizMode = false }) => {
  const navigate = useNavigate();
  const { data: coursesData, isLoading, refetch } = useCourses();
  const [enrollDialog, setEnrollDialog] = useState(false);
  const [selectedCourse, setSelectedCourse] = useState(null);
  const [enrolling, setEnrolling] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  if (isLoading) return <LoadingSpinner />;

  const courses = coursesData?.data?.courses || [];
  
  // Filter courses based on props
  let filteredCourses = courses;
  if (!showAll) {
    filteredCourses = courses.filter(course => 
      course.enrollmentStatus === 'approved' || course.enrollmentStatus === 'pending'
    );
  }

  const handleEnrollRequest = async () => {
    setEnrolling(true);
    setError('');
    
    try {
      await enrollmentAPI.request(selectedCourse.courseId);
      setSuccess('Richiesta di iscrizione inviata con successo!');
      setEnrollDialog(false);
      await refetch();
    } catch (error) {
      setError('Errore durante la richiesta di iscrizione');
      console.error('Error requesting enrollment:', error);
    } finally {
      setEnrolling(false);
    }
  };

  const getStatusChip = (status) => {
    switch (status) {
      case 'approved':
        return <Chip icon={<ApprovedIcon />} label="Iscritto" color="success" size="small" />;
      case 'pending':
        return <Chip icon={<PendingIcon />} label="In attesa" color="warning" size="small" />;
      case 'rejected':
        return <Chip label="Rifiutato" color="error" size="small" />;
      default:
        return null;
    }
  };

  const handleCourseClick = (course) => {
    if (course.enrollmentStatus === 'approved') {
      if (quizMode) {
        navigate(`/student/course/${course.courseId}?quizMode=true`);
      } else {
        navigate(`/student/course/${course.courseId}`);
      }
    } else {
      setSelectedCourse(course);
      setEnrollDialog(true);
    }
  };

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        {showAll ? 'Corsi Disponibili' : (quizMode ? 'I Miei Quiz' : 'I Miei Corsi')}
      </Typography>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }} onClose={() => setError('')}>
          {error}
        </Alert>
      )}

      {success && (
        <Alert severity="success" sx={{ mb: 2 }} onClose={() => setSuccess('')}>
          {success}
        </Alert>
      )}

      <Grid container spacing={3}>
        {filteredCourses.map((course) => (
          <Grid item xs={12} sm={6} md={4} key={course.courseId}>
            <Card>
              <CardContent>
                <Box display="flex" justifyContent="space-between" alignItems="start" mb={1}>
                  <SchoolIcon color="primary" />
                  {getStatusChip(course.enrollmentStatus)}
                </Box>
                
                <Typography variant="h5" component="div" gutterBottom>
                  {course.name}
                </Typography>
                
                <Typography variant="body2" color="text.secondary">
                  {course.description}
                </Typography>
                
                <Typography variant="caption" display="block" sx={{ mt: 2 }}>
                  Docente: {course.teacherEmail}
                </Typography>
              </CardContent>
              
              <CardActions>
                {course.enrollmentStatus === 'approved' ? (
                  <Button 
                    size="small" 
                    onClick={() => handleCourseClick(course)}
                    fullWidth
                    variant="contained"
                  >
                    {quizMode ? 'Vedi Quiz' : 'Accedi al Corso'}
                  </Button>
                ) : course.enrollmentStatus === 'pending' ? (
                  <Button size="small" disabled fullWidth>
                    In attesa di approvazione
                  </Button>
                ) : course.enrollmentStatus === 'rejected' ? (
                  <Button size="small" disabled fullWidth color="error">
                    Iscrizione rifiutata
                  </Button>
                ) : (
                  <Button 
                    size="small" 
                    startIcon={<EnrollIcon />}
                    onClick={() => handleCourseClick(course)}
                    fullWidth
                    variant="outlined"
                  >
                    Richiedi Iscrizione
                  </Button>
                )}
              </CardActions>
            </Card>
          </Grid>
        ))}
      </Grid>

      {/* Enrollment Dialog */}
      <Dialog open={enrollDialog} onClose={() => !enrolling && setEnrollDialog(false)}>
        <DialogTitle>Richiesta di Iscrizione</DialogTitle>
        <DialogContent>
          <DialogContentText>
            Vuoi richiedere l'iscrizione al corso "{selectedCourse?.name}"?
            <br /><br />
            Il docente riceverà una notifica e dovrà approvare la tua richiesta 
            prima che tu possa accedere ai contenuti del corso.
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setEnrollDialog(false)} disabled={enrolling}>
            Annulla
          </Button>
          <Button onClick={handleEnrollRequest} variant="contained" disabled={enrolling}>
            {enrolling ? 'Invio in corso...' : 'Invia Richiesta'}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default CourseList;



PATH: /elearning-platform/src/frontend/src/components/teacher/TeacherDashboard.jsx

import React from 'react';
import { Routes, Route, useNavigate } from 'react-router-dom';
import {
  Box,
  Drawer,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  ListItemButton,
  Toolbar,
} from '@mui/material';
import {
  School as SchoolIcon,
  Assignment as AssignmentIcon,
  People as PeopleIcon,
} from '@mui/icons-material';
import Header from '../common/Header';
import CourseManager from './CourseManager';
import EnrollmentApproval from './EnrollmentApproval';
import DocumentUpload from './DocumentUpload';

const drawerWidth = 240;

const TeacherDashboard = () => {
  const navigate = useNavigate();

  const menuItems = [
    { text: 'I miei corsi', icon: <SchoolIcon />, path: '/teacher' },
    { text: 'Gestione iscrizioni', icon: <PeopleIcon />, path: '/teacher/enrollments' },
    { text: 'Documenti', icon: <AssignmentIcon />, path: '/teacher/documents' },
  ];

  return (
    <Box sx={{ display: 'flex' }}>
      <Header title="Dashboard Docente" />
      
      <Drawer
        variant="permanent"
        sx={{
          width: drawerWidth,
          flexShrink: 0,
          '& .MuiDrawer-paper': {
            width: drawerWidth,
            boxSizing: 'border-box',
          },
        }}
      >
        <Toolbar />
        <Box sx={{ overflow: 'auto' }}>
          <List>
            {menuItems.map((item) => (
              <ListItem key={item.text} disablePadding>
                <ListItemButton onClick={() => navigate(item.path)}>
                  <ListItemIcon>{item.icon}</ListItemIcon>
                  <ListItemText primary={item.text} />
                </ListItemButton>
              </ListItem>
            ))}
          </List>
        </Box>
      </Drawer>
      
      <Box component="main" sx={{ flexGrow: 1, p: 3 }}>
        <Toolbar />
        <Routes>
          <Route path="/" element={<CourseManager />} />
          <Route path="/enrollments" element={<EnrollmentApproval />} />
          <Route path="/documents" element={<DocumentUpload />} />
        </Routes>
      </Box>
    </Box>
  );
};

export default TeacherDashboard;



PATH: /elearning-platform/src/frontend/src/components/teacher/EnrollmentApproval.jsx

import React, { useState, useEffect } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  Chip,
  Grid,
  Alert,
  Tabs,
  Tab,
  Avatar,
  List,
  ListItem,
  ListItemAvatar,
  ListItemText,
  ListItemSecondaryAction,
  IconButton,
  Divider,
} from '@mui/material';
import {
  Check as CheckIcon,
  Close as CloseIcon,
  Person as PersonIcon,
} from '@mui/icons-material';
import { enrollmentAPI } from '../../services/api';
import { useCourses } from '../../hooks/useCourses';
import LoadingSpinner from '../common/LoadingSpinner';

const EnrollmentApproval = () => {
  const { data: coursesData, isLoading } = useCourses();
  const [selectedCourse, setSelectedCourse] = useState(null);
  const [enrollments, setEnrollments] = useState({ pending: [], approved: [], rejected: [] });
  const [loadingEnrollments, setLoadingEnrollments] = useState(false);
  const [error, setError] = useState('');
  const [tabValue, setTabValue] = useState(0);

  const courses = coursesData?.data?.courses || [];

  // eslint-disable-next-line react-hooks/exhaustive-deps
  useEffect(() => {
    if (selectedCourse) {
      fetchEnrollments();
    }
  }, [selectedCourse]);

  const fetchEnrollments = async () => {
    setLoadingEnrollments(true);
    setError('');
    try {
      const response = await enrollmentAPI.list(selectedCourse);
      setEnrollments(response.data.enrollments);
    } catch (error) {
      setError('Errore nel caricamento delle iscrizioni');
      console.error('Error fetching enrollments:', error);
    } finally {
      setLoadingEnrollments(false);
    }
  };

  const handleApproval = async (studentId, action) => {
    try {
      await enrollmentAPI.approve(selectedCourse, studentId, action);
      await fetchEnrollments(); // Refresh list
    } catch (error) {
      setError(`Errore durante ${action === 'approve' ? 'l\'approvazione' : 'il rifiuto'}`);
      console.error('Error updating enrollment:', error);
    }
  };

  if (isLoading) return <LoadingSpinner />;

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Gestione Iscrizioni
      </Typography>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}

      {/* Course Selection */}
      <Grid container spacing={2} sx={{ mb: 3 }}>
        {courses.map((course) => (
          <Grid item xs={12} sm={6} md={4} key={course.courseId}>
            <Card
              sx={{
                cursor: 'pointer',
                border: selectedCourse === course.courseId ? '2px solid' : '1px solid #e0e0e0',
                borderColor: selectedCourse === course.courseId ? 'primary.main' : '#e0e0e0',
              }}
              onClick={() => setSelectedCourse(course.courseId)}
            >
              <CardContent>
                <Typography variant="h6">{course.name}</Typography>
                <Typography variant="body2" color="text.secondary">
                  {course.description}
                </Typography>
              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>

      {/* Enrollments */}
      {selectedCourse && (
        <Card>
          <CardContent>
            <Tabs value={tabValue} onChange={(e, v) => setTabValue(v)} sx={{ mb: 2 }}>
              <Tab 
                label={`In attesa (${enrollments.pending.length})`} 
                icon={<Chip size="small" label={enrollments.pending.length} color="warning" />}
                iconPosition="end"
              />
              <Tab 
                label={`Approvati (${enrollments.approved.length})`}
                icon={<Chip size="small" label={enrollments.approved.length} color="success" />}
                iconPosition="end"
              />
              <Tab 
                label={`Rifiutati (${enrollments.rejected.length})`}
                icon={<Chip size="small" label={enrollments.rejected.length} color="error" />}
                iconPosition="end"
              />
            </Tabs>

            {loadingEnrollments ? (
              <LoadingSpinner />
            ) : (
              <>
                {/* Pending */}
                {tabValue === 0 && (
                  <List>
                    {enrollments.pending.length === 0 ? (
                      <Typography variant="body2" color="text.secondary" textAlign="center">
                        Nessuna richiesta in attesa
                      </Typography>
                    ) : (
                      enrollments.pending.map((enrollment) => (
                        <React.Fragment key={enrollment.studentId}>
                          <ListItem>
                            <ListItemAvatar>
                              <Avatar>
                                <PersonIcon />
                              </Avatar>
                            </ListItemAvatar>
                            <ListItemText
                              primary={enrollment.studentEmail}
                              secondary={`Richiesta: ${new Date(enrollment.requestedAt).toLocaleString()}`}
                            />
                            <ListItemSecondaryAction>
                              <IconButton
                                edge="end"
                                color="success"
                                onClick={() => handleApproval(enrollment.studentId, 'approve')}
                                sx={{ mr: 1 }}
                              >
                                <CheckIcon />
                              </IconButton>
                              <IconButton
                                edge="end"
                                color="error"
                                onClick={() => handleApproval(enrollment.studentId, 'reject')}
                              >
                                <CloseIcon />
                              </IconButton>
                            </ListItemSecondaryAction>
                          </ListItem>
                          <Divider />
                        </React.Fragment>
                      ))
                    )}
                  </List>
                )}

                {/* Approved */}
                {tabValue === 1 && (
                  <List>
                    {enrollments.approved.length === 0 ? (
                      <Typography variant="body2" color="text.secondary" textAlign="center">
                        Nessuno studente approvato
                      </Typography>
                    ) : (
                      enrollments.approved.map((enrollment) => (
                        <React.Fragment key={enrollment.studentId}>
                          <ListItem>
                            <ListItemAvatar>
                              <Avatar sx={{ bgcolor: 'success.main' }}>
                                <PersonIcon />
                              </Avatar>
                            </ListItemAvatar>
                            <ListItemText
                              primary={enrollment.studentEmail}
                              secondary={`Approvato: ${new Date(enrollment.updatedAt).toLocaleString()}`}
                            />
                          </ListItem>
                          <Divider />
                        </React.Fragment>
                      ))
                    )}
                  </List>
                )}

                {/* Rejected */}
                {tabValue === 2 && (
                  <List>
                    {enrollments.rejected.length === 0 ? (
                      <Typography variant="body2" color="text.secondary" textAlign="center">
                        Nessuna richiesta rifiutata
                      </Typography>
                    ) : (
                      enrollments.rejected.map((enrollment) => (
                        <React.Fragment key={enrollment.studentId}>
                          <ListItem>
                            <ListItemAvatar>
                              <Avatar sx={{ bgcolor: 'error.main' }}>
                                <PersonIcon />
                              </Avatar>
                            </ListItemAvatar>
                            <ListItemText
                              primary={enrollment.studentEmail}
                              secondary={`Rifiutato: ${new Date(enrollment.updatedAt).toLocaleString()}`}
                            />
                          </ListItem>
                          <Divider />
                        </React.Fragment>
                      ))
                    )}
                  </List>
                )}
              </>
            )}
          </CardContent>
        </Card>
      )}
    </Box>
  );
};

export default EnrollmentApproval;



PATH: /elearning-platform/src/frontend/src/components/teacher/DocumentUpload.jsx

import React, { useState, useEffect } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  Button,
  Grid,
  Alert,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  LinearProgress,
  Chip,
  Divider,
} from '@mui/material';
import {
  CloudUpload as UploadIcon,
  Delete as DeleteIcon,
  Download as DownloadIcon,
  PictureAsPdf as PdfIcon,
  Quiz as QuizIcon,
} from '@mui/icons-material';
import { documentAPI } from '../../services/api';
import { useCourses } from '../../hooks/useCourses';
import LoadingSpinner from '../common/LoadingSpinner';

const DocumentUpload = () => {
  const { data: coursesData, isLoading } = useCourses();
  const [selectedCourse, setSelectedCourse] = useState(null);
  const [documents, setDocuments] = useState([]);
  const [loadingDocuments, setLoadingDocuments] = useState(false);
  const [uploadDialog, setUploadDialog] = useState(false);
  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  const courses = coursesData?.data?.courses || [];

  // eslint-disable-next-line react-hooks/exhaustive-deps
  useEffect(() => {
    if (selectedCourse) {
      fetchDocuments();
    }
  }, [selectedCourse]);

  const fetchDocuments = async () => {
    setLoadingDocuments(true);
    setError('');
    try {
      const response = await documentAPI.list(selectedCourse);
      setDocuments(response.data.documents);
    } catch (error) {
      setError('Errore nel caricamento dei documenti');
      console.error('Error fetching documents:', error);
    } finally {
      setLoadingDocuments(false);
    }
  };

  const handleFileSelect = async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    if (!file.name.toLowerCase().endsWith('.pdf')) {
      setError('Solo file PDF sono permessi');
      return;
    }

    setError('');
    setSuccess('');
    setUploading(true);
    setUploadProgress(0);

    try {
      // Get presigned URL
      const response = await documentAPI.getUploadUrl(
        selectedCourse,
        file.name,
        file.size
      );

      const { uploadUrl } = response.data;

      // Upload file to S3
      const xhr = new XMLHttpRequest();

      xhr.upload.addEventListener('progress', (e) => {
        if (e.lengthComputable) {
          const percentComplete = (e.loaded / e.total) * 100;
          setUploadProgress(percentComplete);
        }
      });

      xhr.addEventListener('load', async () => {
        if (xhr.status === 200) {
          setSuccess('Documento caricato con successo!');
          setUploadDialog(false);
          await fetchDocuments();
        } else {
          setError('Errore durante il caricamento');
        }
        setUploading(false);
      });

      xhr.addEventListener('error', () => {
        setError('Errore durante il caricamento');
        setUploading(false);
      });

      xhr.open('PUT', uploadUrl);
      xhr.setRequestHeader('Content-Type', 'application/pdf');
      xhr.send(file);

    } catch (error) {
      setError('Errore durante la richiesta di upload');
      setUploading(false);
      console.error('Error uploading:', error);
    }
  };

  const handleDownload = async (document) => {
    try {
      const response = await documentAPI.getDownloadUrl(selectedCourse, document.documentId);
      window.open(response.data.downloadUrl, '_blank');
    } catch (error) {
      setError('Errore durante il download');
      console.error('Error downloading:', error);
    }
  };

  const handleDelete = async (documentId) => {
    if (!window.confirm('Sei sicuro di voler eliminare questo documento?')) {
      return;
    }

    try {
      await documentAPI.delete(selectedCourse, documentId);
      setSuccess('Documento eliminato con successo');
      await fetchDocuments();
    } catch (error) {
      setError('Errore durante l\'eliminazione');
      console.error('Error deleting:', error);
    }
  };

  if (isLoading) return <LoadingSpinner />;

  return (
    <Box>
      <Typography variant="h4" gutterBottom>
        Gestione Documenti
      </Typography>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }} onClose={() => setError('')}>
          {error}
        </Alert>
      )}

      {success && (
        <Alert severity="success" sx={{ mb: 2 }} onClose={() => setSuccess('')}>
          {success}
        </Alert>
      )}

      {/* Course Selection */}
      <Grid container spacing={2} sx={{ mb: 3 }}>
        {courses.map((course) => (
          <Grid item xs={12} sm={6} md={4} key={course.courseId}>
            <Card
              sx={{
                cursor: 'pointer',
                border: selectedCourse === course.courseId ? '2px solid' : '1px solid #e0e0e0',
                borderColor: selectedCourse === course.courseId ? 'primary.main' : '#e0e0e0',
              }}
              onClick={() => setSelectedCourse(course.courseId)}
            >
              <CardContent>
                <Typography variant="h6">{course.name}</Typography>
                <Typography variant="body2" color="text.secondary">
                  {course.description}
                </Typography>
              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>

      {/* Documents */}
      {selectedCourse && (
        <Card>
          <CardContent>
            <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
              <Typography variant="h6">Documenti del corso</Typography>
              <Button
                variant="contained"
                startIcon={<UploadIcon />}
                onClick={() => setUploadDialog(true)}
              >
                Carica PDF
              </Button>
            </Box>

            <Divider sx={{ mb: 2 }} />

            {loadingDocuments ? (
              <LoadingSpinner />
            ) : documents.length === 0 ? (
              <Typography variant="body2" color="text.secondary" textAlign="center">
                Nessun documento caricato
              </Typography>
            ) : (
              <List>
                {documents.map((doc) => (
                  <React.Fragment key={doc.documentId}>
                    <ListItem>
                      <PdfIcon sx={{ mr: 2, color: 'error.main' }} />
                      <ListItemText
                        primary={doc.name}
                        secondary={
                          <Box>
                            <Typography variant="caption" display="block">
                              Caricato: {new Date(doc.uploadedAt).toLocaleString()}
                            </Typography>
                            <Box sx={{ mt: 1 }}>
                              <Chip
                                label={doc.status}
                                size="small"
                                color={doc.status === 'ready' ? 'success' : 'warning'}
                                sx={{ mr: 1 }}
                              />
                              {doc.quizId && (
                                <Chip
                                  icon={<QuizIcon />}
                                  label="Quiz disponibile"
                                  size="small"
                                  color="primary"
                                />
                              )}
                            </Box>
                          </Box>
                        }
                      />
                      <ListItemSecondaryAction>
                        <IconButton
                          edge="end"
                          onClick={() => handleDownload(doc)}
                          sx={{ mr: 1 }}
                        >
                          <DownloadIcon />
                        </IconButton>
                        <IconButton
                          edge="end"
                          color="error"
                          onClick={() => handleDelete(doc.documentId)}
                        >
                          <DeleteIcon />
                        </IconButton>
                      </ListItemSecondaryAction>
                    </ListItem>
                    <Divider />
                  </React.Fragment>
                ))}
              </List>
            )}
          </CardContent>
        </Card>
      )}

      {/* Upload Dialog */}
      <Dialog open={uploadDialog} onClose={() => !uploading && setUploadDialog(false)}>
        <DialogTitle>Carica Documento PDF</DialogTitle>
        <DialogContent>
          <Box sx={{ mt: 2 }}>
            <input
              accept="application/pdf"
              style={{ display: 'none' }}
              id="pdf-file-input"
              type="file"
              onChange={handleFileSelect}
              disabled={uploading}
            />
            <label htmlFor="pdf-file-input">
              <Button
                variant="outlined"
                component="span"
                startIcon={<UploadIcon />}
                disabled={uploading}
                fullWidth
              >
                Seleziona file PDF
              </Button>
            </label>

            {uploading && (
              <Box sx={{ mt: 2 }}>
                <Typography variant="body2" gutterBottom>
                  Caricamento in corso...
                </Typography>
                <LinearProgress variant="determinate" value={uploadProgress} />
                <Typography variant="caption" color="text.secondary">
                  {Math.round(uploadProgress)}%
                </Typography>
              </Box>
            )}
          </Box>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setUploadDialog(false)} disabled={uploading}>
            Chiudi
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default DocumentUpload;



PATH: /elearning-platform/src/frontend/src/components/teacher/CourseManager.jsx

import React, { useState } from 'react';
import {
  Box,
  Button,
  Card,
  CardContent,
  CardActions,
  Grid,
  Typography,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  IconButton,
  Alert,
} from '@mui/material';
import {
  Add as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
} from '@mui/icons-material';
import { useCourses, useCreateCourse, useUpdateCourse, useDeleteCourse } from '../../hooks/useCourses';
import LoadingSpinner from '../common/LoadingSpinner';

const CourseManager = () => {
  const { data: courses, isLoading, error } = useCourses();
  const createCourse = useCreateCourse();
  const updateCourse = useUpdateCourse();
  const deleteCourse = useDeleteCourse();
  
  const [dialogOpen, setDialogOpen] = useState(false);
  const [editingCourse, setEditingCourse] = useState(null);
  const [formData, setFormData] = useState({
    name: '',
    description: '',
  });

  const handleOpenDialog = (course = null) => {
    if (course) {
      setEditingCourse(course);
      setFormData({
        name: course.name,
        description: course.description,
      });
    } else {
      setEditingCourse(null);
      setFormData({ name: '', description: '' });
    }
    setDialogOpen(true);
  };

  const handleCloseDialog = () => {
    setDialogOpen(false);
    setEditingCourse(null);
    setFormData({ name: '', description: '' });
  };

  const handleSubmit = async () => {
    try {
      if (editingCourse) {
        await updateCourse.mutateAsync({
          courseId: editingCourse.courseId,
          data: formData,
        });
      } else {
        await createCourse.mutateAsync(formData);
      }
      handleCloseDialog();
    } catch (error) {
      console.error('Error saving course:', error);
    }
  };

  const handleDelete = async (courseId) => {
    if (window.confirm('Sei sicuro di voler eliminare questo corso?')) {
      try {
        await deleteCourse.mutateAsync(courseId);
      } catch (error) {
        console.error('Error deleting course:', error);
      }
    }
  };

  if (isLoading) return <LoadingSpinner />;
  if (error) return <Alert severity="error">Errore nel caricamento dei corsi</Alert>;

  const teacherCourses = courses?.data?.courses || [];

  return (
    <Box>
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Typography variant="h4">I miei corsi</Typography>
        <Button
          variant="contained"
          startIcon={<AddIcon />}
          onClick={() => handleOpenDialog()}
        >
          Nuovo Corso
        </Button>
      </Box>

      <Grid container spacing={3}>
        {teacherCourses.map((course) => (
          <Grid item xs={12} sm={6} md={4} key={course.courseId}>
            <Card>
              <CardContent>
                <Typography variant="h5" component="div" gutterBottom>
                  {course.name}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  {course.description}
                </Typography>
                <Typography variant="caption" display="block" sx={{ mt: 2 }}>
                  Creato: {new Date(course.createdAt).toLocaleDateString()}
                </Typography>
              </CardContent>
              <CardActions>
                <IconButton onClick={() => handleOpenDialog(course)} color="primary">
                  <EditIcon />
                </IconButton>
                <IconButton onClick={() => handleDelete(course.courseId)} color="error">
                  <DeleteIcon />
                </IconButton>
              </CardActions>
            </Card>
          </Grid>
        ))}
      </Grid>

      {/* Dialog for Create/Edit */}
      <Dialog open={dialogOpen} onClose={handleCloseDialog} maxWidth="sm" fullWidth>
        <DialogTitle>
          {editingCourse ? 'Modifica Corso' : 'Nuovo Corso'}
        </DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="Nome del corso"
            fullWidth
            variant="outlined"
            value={formData.name}
            onChange={(e) => setFormData({ ...formData, name: e.target.value })}
            sx={{ mb: 2 }}
          />
          <TextField
            margin="dense"
            label="Descrizione"
            fullWidth
            multiline
            rows={4}
            variant="outlined"
            value={formData.description}
            onChange={(e) => setFormData({ ...formData, description: e.target.value })}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog}>Annulla</Button>
          <Button onClick={handleSubmit} variant="contained">
            {editingCourse ? 'Salva' : 'Crea'}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default CourseManager;



PATH: /elearning-platform/src/frontend/src/hooks/useAuth.js

import React, { createContext, useContext, useState, useEffect } from 'react';
import { authService } from '../services/auth';

const AuthContext = createContext();

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  // eslint-disable-next-line react-hooks/exhaustive-deps
  useEffect(() => {
    checkAuth();
  }, []);

  const checkAuth = async () => {
    try {
      const currentUser = await authService.getCurrentUser();
      setUser(currentUser);
    } catch (error) {
      console.error('Error checking auth:', error);
    } finally {
      setLoading(false);
    }
  };

  const signIn = async (email, password) => {
    await authService.signIn(email, password);
    const currentUser = await authService.getCurrentUser();
    setUser(currentUser);
    return currentUser;
  };

  const signOut = async () => {
    await authService.signOut();
    setUser(null);
  };

  const value = {
    user,
    loading,
    signIn,
    signOut,
    checkAuth,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};



PATH: /elearning-platform/src/frontend/src/hooks/useCourses.js

import { useQuery, useMutation, useQueryClient } from 'react-query';
import { courseAPI } from '../services/api';

export const useCourses = () => {
  return useQuery('courses', courseAPI.list, {
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
};

export const useCourse = (courseId) => {
  return useQuery(['course', courseId], () => courseAPI.get(courseId), {
    enabled: !!courseId,
  });
};

export const useCreateCourse = () => {
  const queryClient = useQueryClient();
  
  return useMutation(courseAPI.create, {
    onSuccess: () => {
      queryClient.invalidateQueries('courses');
    },
  });
};

export const useUpdateCourse = () => {
  const queryClient = useQueryClient();
  
  return useMutation(
    ({ courseId, data }) => courseAPI.update(courseId, data),
    {
      onSuccess: (_, { courseId }) => {
        queryClient.invalidateQueries(['course', courseId]);
        queryClient.invalidateQueries('courses');
      },
    }
  );
};

export const useDeleteCourse = () => {
  const queryClient = useQueryClient();
  
  return useMutation(courseAPI.delete, {
    onSuccess: () => {
      queryClient.invalidateQueries('courses');
    },
  });
};




PATH: /elearning-platform/src/frontend/src/services/api.js

import axios from 'axios';
import { Auth } from 'aws-amplify';

const API_URL = process.env.REACT_APP_API_ENDPOINT;

const api = axios.create({
  baseURL: API_URL,
});

// Add auth token to requests
api.interceptors.request.use(async (config) => {
  try {
    const session = await Auth.currentSession();
    const token = session.getIdToken().getJwtToken();
    config.headers.Authorization = `Bearer ${token}`;
  } catch (error) {
    console.error('Error getting auth token:', error);
  }
  return config;
});

// Course APIs
export const courseAPI = {
  list: () => api.get('/courses'),
  create: (data) => api.post('/courses', data),
  get: (courseId) => api.get(`/courses/${courseId}`),
  update: (courseId, data) => api.put(`/courses/${courseId}`, data),
  delete: (courseId) => api.delete(`/courses/${courseId}`),
};

// Enrollment APIs
export const enrollmentAPI = {
  list: (courseId) => api.get(`/courses/${courseId}/enrollments`),
  request: (courseId) => api.post(`/courses/${courseId}/enrollments`),
  approve: (courseId, studentId, action) => 
    api.put(`/courses/${courseId}/enrollments/${studentId}`, { action }),
};

// Document APIs
export const documentAPI = {
  list: (courseId) => api.get(`/courses/${courseId}/documents`),
  getUploadUrl: (courseId, fileName, fileSize) => 
    api.post(`/courses/${courseId}/documents`, { 
      fileName, 
      fileSize, 
      action: 'upload' 
    }),
  getDownloadUrl: (courseId, documentId) =>
    api.get(`/courses/${courseId}/documents/${documentId}`),
  delete: (courseId, documentId) => 
    api.delete(`/courses/${courseId}/documents/${documentId}`),
};

// Quiz APIs
export const quizAPI = {
  get: (courseId, documentId) => 
    api.get(`/courses/${courseId}/documents/${documentId}/quiz`),
  submit: (courseId, documentId, answers) =>
    api.post(`/courses/${courseId}/documents/${documentId}/quiz`, answers),
};

// Results APIs
export const resultsAPI = {
  list: () => api.get('/results'),
};

export default api;



PATH: /elearning-platform/src/frontend/src/services/auth.js

import { Auth } from 'aws-amplify';

export const authService = {
  async signUp(email, password, name, familyName, role) {
    try {
      const { user } = await Auth.signUp({
        username: email,
        password,
        attributes: {
          email,
          name,
          family_name: familyName,
          'custom:role': role,
        },
      });
      return user;
    } catch (error) {
      console.error('SignUp Error Details:', error);
      throw error;
    }
  },

  async confirmSignUp(email, code) {
    try {
      await Auth.confirmSignUp(email, code);
    } catch (error) {
      throw error;
    }
  },

  async signIn(email, password) {
    try {
      const user = await Auth.signIn(email, password);
      return user;
    } catch (error) {
      console.error('SignIn Error Details:', error);
      throw error;
    }
  },

  async signOut() {
    try {
      await Auth.signOut();
    } catch (error) {
      throw error;
    }
  },

  async forgotPassword(email) {
    try {
      await Auth.forgotPassword(email);
    } catch (error) {
      throw error;
    }
  },

  async forgotPasswordSubmit(email, code, password) {
    try {
      await Auth.forgotPasswordSubmit(email, code, password);
    } catch (error) {
      throw error;
    }
  },

  async getCurrentUser() {
    try {
      const user = await Auth.currentAuthenticatedUser();
      const attributes = await Auth.userAttributes(user);
      
      const role = attributes.find(attr => attr.Name === 'custom:role')?.Value;
      const groups = user.signInUserSession.idToken.payload['cognito:groups'] || [];
      
      return {
        username: user.username,
        email: user.attributes.email,
        name: user.attributes.name,
        familyName: user.attributes.family_name,
        role,
        groups,
        isTeacher: groups.includes('Docenti'),
        isStudent: groups.includes('Studenti'),
      };
    } catch (error) {
      return null;
    }
  },
};




PATH: /elearning-platform/src/frontend/src/services/storage.js

export const storage = {
  setItem: (key, value) => {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error('Error saving to localStorage:', error);
    }
  },

  getItem: (key) => {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : null;
    } catch (error) {
      console.error('Error reading from localStorage:', error);
      return null;
    }
  },

  removeItem: (key) => {
    try {
      localStorage.removeItem(key);
    } catch (error) {
      console.error('Error removing from localStorage:', error);
    }
  },

  clear: () => {
    try {
      localStorage.clear();
    } catch (error) {
      console.error('Error clearing localStorage:', error);
    }
  },
};




PATH: /elearning-platform/src/frontend/src/utils/constants.js

export const ROLES = {
  TEACHER: 'Docenti',
  STUDENT: 'Studenti',
};

export const ENROLLMENT_STATUS = {
  PENDING: 'pending',
  APPROVED: 'approved',
  REJECTED: 'rejected',
};

export const DOCUMENT_STATUS = {
  PENDING: 'pending',
  READY: 'ready',
  FAILED: 'failed',
};

export const QUIZ_PASSING_SCORE = 60;

export const API_ENDPOINTS = {
  COURSES: '/courses',
  ENROLLMENTS: '/enrollments',
  DOCUMENTS: '/documents',
  QUIZ: '/quiz',
  RESULTS: '/results',
};

export const ERROR_MESSAGES = {
  GENERIC: 'Si è verificato un errore. Riprova più tardi.',
  UNAUTHORIZED: 'Non sei autorizzato a eseguire questa operazione.',
  NOT_FOUND: 'Risorsa non trovata.',
  NETWORK: 'Errore di connessione. Verifica la tua connessione internet.',
};

export const SUCCESS_MESSAGES = {
  COURSE_CREATED: 'Corso creato con successo!',
  COURSE_UPDATED: 'Corso aggiornato con successo!',
  COURSE_DELETED: 'Corso eliminato con successo!',
  ENROLLMENT_REQUESTED: 'Richiesta di iscrizione inviata!',
  ENROLLMENT_APPROVED: 'Iscrizione approvata!',
  ENROLLMENT_REJECTED: 'Iscrizione rifiutata!',
  DOCUMENT_UPLOADED: 'Documento caricato con successo!',
  DOCUMENT_DELETED: 'Documento eliminato con successo!',
  QUIZ_SUBMITTED: 'Quiz completato con successo!',
};



PATH: /elearning-platform/terraform/main.tf

terraform {
  required_version = ">= 1.0"
  
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
  
  default_tags {
    tags = {
      Project     = "elearning-platform"
      Environment = var.environment
      ManagedBy   = "terraform"
    }
  }
}

# Moduli
module "networking" {
  source = "./modules/networking"
  
  project_name = var.project_name
  environment  = var.environment
  vpc_cidr     = var.vpc_cidr
  
  public_subnet_cidrs  = var.public_subnet_cidrs
  private_subnet_cidrs = var.private_subnet_cidrs
  availability_zones   = var.availability_zones
}

module "cognito" {
  source = "./modules/cognito"
  
  project_name = var.project_name
  environment  = var.environment
  # domain_name  = var.domain_name
  # domain_name  = local.eb_domain # Rimosso non più necessario
}

module "storage" {
  source = "./modules/storage"
  
  project_name = var.project_name
  environment  = var.environment
  # domain_name  = var.domain_name
  # domain_name  = local.eb_domain # Rimosso non più necessario
}

# Messaging module
module "messaging" {
  source = "./modules/messaging"
  
  project_name = var.project_name
  environment  = var.environment
  admin_email  = var.admin_email
}

module "compute" {
  source = "./modules/compute"
  
  project_name = var.project_name
  environment  = var.environment
  
  # Cognito
  user_pool_id  = module.cognito.user_pool_id
  user_pool_arn = module.cognito.user_pool_arn
  
  # DynamoDB Tables
  courses_table_name     = module.storage.courses_table_name
  courses_table_arn      = module.storage.courses_table_arn
  enrollments_table_name = module.storage.enrollments_table_name
  enrollments_table_arn  = module.storage.enrollments_table_arn
  documents_table_name   = module.storage.documents_table_name
  documents_table_arn    = module.storage.documents_table_arn
  quizzes_table_name     = module.storage.quizzes_table_name
  quizzes_table_arn      = module.storage.quizzes_table_arn
  results_table_name     = module.storage.results_table_name
  results_table_arn      = module.storage.results_table_arn
  
  # S3 Buckets
  documents_bucket_name = module.storage.documents_bucket_name
  documents_bucket_arn  = module.storage.documents_bucket_arn

  # Add SNS topic ARN
  enrollment_notification_topic_arn = module.messaging.enrollment_notifications_topic_arn
}

# Compute ECS module
module "compute_ecs" {
  source = "./modules/compute_ecs"
  
  project_name = var.project_name
  environment  = var.environment
  
  vpc_id                = module.networking.vpc_id
  private_subnet_ids    = module.networking.private_subnet_ids
  ecs_security_group_id = module.networking.ecs_security_group_id
  
  # DynamoDB Tables
  documents_table_name = module.storage.documents_table_name
  documents_table_arn  = module.storage.documents_table_arn
  quizzes_table_name   = module.storage.quizzes_table_name
  quizzes_table_arn    = module.storage.quizzes_table_arn
  
  # S3 Bucket
  documents_bucket_name = module.storage.documents_bucket_name
  documents_bucket_arn  = module.storage.documents_bucket_arn
  
  # SQS Queue
  document_processing_queue_arn = module.messaging.document_processing_queue_arn
  document_processing_queue_url = module.messaging.document_processing_queue_url
  
  depends_on = [module.messaging]
}

# Elastic Beanstalk module
module "elastic_beanstalk" {
  source = "./modules/elastic_beanstalk"
  
  project_name = var.project_name
  environment  = var.environment
  
  vpc_id                = module.networking.vpc_id
  public_subnet_ids     = module.networking.public_subnet_ids
  alb_security_group_id = module.networking.alb_security_group_id
  
  user_pool_id        = module.cognito.user_pool_id
  user_pool_client_id = module.cognito.web_client_id
  api_gateway_url     = module.compute.api_gateway_invoke_url
  
  depends_on = [
    module.networking,
    module.cognito,
    module.compute
  ]
}

# Outputs principali
output "vpc_id" {
  description = "ID del VPC"
  value       = module.networking.vpc_id
}

output "public_subnet_ids" {
  description = "IDs delle subnet pubbliche"
  value       = module.networking.public_subnet_ids
}

output "private_subnet_ids" {
  description = "IDs delle subnet private"
  value       = module.networking.private_subnet_ids
}



PATH: /elearning-platform/terraform/outputs.tf

# Output generali del progetto

output "region" {
  description = "AWS region"
  value       = var.aws_region
}

output "environment" {
  description = "Nome dell'ambiente"
  value       = var.environment
}

# Networking outputs
output "vpc_details" {
  description = "Dettagli del VPC"
  value = {
    vpc_id               = module.networking.vpc_id
    vpc_cidr             = module.networking.vpc_cidr
    public_subnet_ids    = module.networking.public_subnet_ids
    private_subnet_ids   = module.networking.private_subnet_ids
    nat_gateway_id       = module.networking.nat_gateway_id
  }
}

output "security_groups" {
  description = "Security Group IDs"
  value = {
    alb_sg_id              = module.networking.alb_security_group_id
    elastic_beanstalk_sg_id = module.networking.elastic_beanstalk_security_group_id
    ecs_sg_id              = module.networking.ecs_security_group_id
    lambda_sg_id           = module.networking.lambda_security_group_id
    rds_sg_id              = module.networking.rds_security_group_id
  }
}

# Cognito outputs
output "cognito_details" {
  description = "Dettagli Cognito"
  value = {
    user_pool_id     = module.cognito.user_pool_id
    user_pool_arn    = module.cognito.user_pool_arn
    web_client_id    = module.cognito.web_client_id
    user_pool_domain = module.cognito.user_pool_domain
  }
  sensitive = true
}

# Storage outputs
output "storage_details" {
  description = "Dettagli Storage"
  value = {
    dynamodb_tables = {
      courses     = module.storage.courses_table_name
      enrollments = module.storage.enrollments_table_name
      documents   = module.storage.documents_table_name
      quizzes     = module.storage.quizzes_table_name
      results     = module.storage.results_table_name
    }
    s3_buckets = {
      documents     = module.storage.documents_bucket_name
      static_assets = module.storage.static_assets_bucket_name
    }
  }
}

# Compute outputs
output "api_details" {
  description = "Dettagli API"
  value = {
    api_gateway_url = module.compute.api_gateway_invoke_url
    api_stage       = module.compute.api_gateway_stage_name
  }
}

output "lambda_functions" {
  description = "Lambda Functions deployate"
  value       = module.compute.lambda_functions
  sensitive   = true
}

# ECS outputs
output "ecs_details" {
  description = "Dettagli ECS"
  value = {
    cluster_name      = module.compute_ecs.ecs_cluster_name
    ecr_repository    = module.compute_ecs.ecr_repository_url
    task_definition   = module.compute_ecs.task_definition_arn
  }
}

output "frontend_url" {
  description = "URL del frontend Elastic Beanstalk"
  value       = "http://${module.elastic_beanstalk.environment_url}"
}



PATH: /elearning-platform/terraform/terraform.tfvars

# Configurazione di esempio per l'ambiente di sviluppo
# Copia questo file in terraform.tfvars e modifica i valori

aws_region   = "us-east-1"
environment  = "dev"
project_name = "elearning"

# Networking
vpc_cidr             = "10.0.0.0/16"
public_subnet_cidrs  = ["10.0.1.0/24"]
private_subnet_cidrs = ["10.0.10.0/24"]
availability_zones   = ["us-east-1a"]

# Admin - Email per notifiche SNS (quando un docente riceve richieste di iscrizione)
# L'email serve per le notifiche SNS quando un docente riceve una richiesta di 
# iscrizione al corso. Nella Fase 5 (Messaging), configureremo SNS per inviare 
# email automatiche ai docenti. Per ora è solo un placeholder.
admin_email = "gabrielesanguedolce@yahoo.it"  # MODIFICARE!

# Domain - Dominio dell'applicazione (per CORS e callback URLs)
# Spiegazione del parametro domain_name
# Il parametro domain_name rappresenta l'URL dove sarà accessibile la tua applicazione web (il frontend React). È utilizzato per:

# CORS (Cross-Origin Resource Sharing): Permette al frontend di fare richieste ai bucket S3
# Cognito Callback URLs: Dove Cognito reindirizza l'utente dopo il login

# Valori tipici:

# Sviluppo locale: localhost:3000 (porta default di React development server)
# Produzione: Il tuo dominio reale, es: app.miodominio.com o elearning.esempio.edu
# Chiarimento su domain_name
# No, NON devi scegliere un dominio ora. Ecco come funziona:

# Per lo sviluppo locale: Lascia localhost:3000
# Quando deployerai su Elastic Beanstalk (Fase 5): AWS ti fornirà un dominio gratuito tipo:

# mia-app.us-east-1.elasticbeanstalk.com

# Solo allora dovrai aggiornare domain_name con il dominio AWS

# Per ora, lascia domain_name = "localhost:3000" in terraform.tfvars.
# domain_name = "localhost:3000"  # Cambiare con il dominio reale in produzione
# domain_name = "http://elearning-dev.eba-jxifqman.us-east-1.elasticbeanstalk.com"


PATH: /elearning-platform/terraform/variables.tf

variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "environment" {
  description = "Nome dell'ambiente (dev, staging, prod)"
  type        = string
  default     = "dev"
}

variable "project_name" {
  description = "Nome del progetto"
  type        = string
  default     = "elearning"
}

variable "vpc_cidr" {
  description = "CIDR block per il VPC"
  type        = string
  default     = "10.0.0.0/16"
}

variable "public_subnet_cidrs" {
  description = "CIDR blocks per le subnet pubbliche"
  type        = list(string)
  default     = ["10.0.1.0/24"]
}

variable "private_subnet_cidrs" {
  description = "CIDR blocks per le subnet private"
  type        = list(string)
  default     = ["10.0.10.0/24"]
}

variable "availability_zones" {
  description = "Availability zones da utilizzare"
  type        = list(string)
  default     = ["us-east-1a"]
}

variable "admin_email" {
  description = "Email dell'amministratore per notifiche"
  type        = string
  default     = ""  # Da configurare in terraform.tfvars
}

# Non più necessario
# variable "domain_name" {
#   description = "Nome dominio per l'applicazione (usato per CORS e callback URLs)"
#   type        = string
#   default     = "localhost:3000"  # Da aggiornare con il dominio reale in produzione
# }

# # Rimosso non più necessario
# # Rimossa la vecchia variabile domain_name e aggiunta:
# locals {
#   # Pattern: app-name-env.region.elasticbeanstalk.com
#   eb_domain = "${var.project_name}-${var.environment}-env.${var.aws_region}.elasticbeanstalk.com"
# }


PATH: /elearning-platform/terraform/s3_notifications.tf

# S3 Event Notifications - created after all modules
resource "aws_s3_bucket_notification" "documents_upload" {
  bucket = module.storage.documents_bucket_name
  
  queue {
    queue_arn     = module.messaging.document_processing_queue_arn
    events        = ["s3:ObjectCreated:*"]
    filter_prefix = "courses/"
    filter_suffix = ".pdf"
  }
  
  depends_on = [
    module.storage,
    module.messaging,
    aws_sqs_queue_policy.allow_s3
  ]
}

# SQS Queue Policy to allow S3 to send messages
resource "aws_sqs_queue_policy" "allow_s3" {
  queue_url = module.messaging.document_processing_queue_url
  
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          Service = "s3.amazonaws.com"
        }
        Action = "sqs:SendMessage"
        Resource = module.messaging.document_processing_queue_arn
        Condition = {
          StringEquals = {
            "aws:SourceArn" = module.storage.documents_bucket_arn
          }
        }
      }
    ]
  })
  
  depends_on = [module.messaging]
}




PATH: /elearning-platform/terraform/README.md

# E-Learning Platform - Infrastructure as Code

## Prerequisiti

1. AWS CLI configurato con credenziali appropriate
2. Terraform >= 1.0

## Struttura del Progetto

```
terraform/
├── main.tf              # Configurazione principale
├── variables.tf         # Variabili globali
├── outputs.tf           # Output principali
├── terraform.tfvars     # Valori delle variabili (non committare!)
├── s3_notifications.tf  # S3 Event Notifications - creato dopo tutti i modules
└── modules/             # Moduli riutilizzabili
    ├── networking/      # VPC, Subnet, Security Groups
    ├── cognito/         # Autenticazione utenti
    ├── storage/         # S3, DynamoDB
    ├── compute/         # Lambda, ECS, Elastic Beanstalk
    ├── messaging/       # SQS, SNS
    └── cicd/           # CodeCommit, CodePipeline
```

## Setup Iniziale

1. **Copia e configura le variabili:**
   ```bash
   cp example.tfvars terraform.tfvars
   # Modifica terraform.tfvars con i tuoi valori
   ```

2. **Inizializza Terraform:**
   ```bash
   terraform init
   ```

## Deployment

### Prima volta
```bash
# Verifica il piano
terraform plan

# Applica le modifiche
terraform apply
```

### Aggiornamenti
```bash
# Sempre verificare prima
terraform plan

# Poi applicare
terraform apply
```

### Distruzione risorse
```bash
# ATTENZIONE: Questo eliminerà TUTTE le risorse!
terraform destroy
```

## Moduli

### Networking
- VPC con subnet pubbliche e private
- NAT Gateway per accesso internet dalle subnet private (1 sola AZ per ridurre costi)
- Security Groups per ogni servizio
- VPC Endpoints per S3 e DynamoDB (risparmio costi)

### Altri moduli (da implementare)
- Cognito: User pools per docenti/studenti
- Storage: S3 buckets e tabelle DynamoDB
- Compute: Lambda functions, ECS cluster, Elastic Beanstalk
- Messaging: Code SQS e topic SNS
- CI/CD: Pipeline automatizzate

## Best Practices

1. **Non committare mai `terraform.tfvars`** - contiene informazioni sensibili
2. **Usa sempre `terraform plan`** prima di applicare modifiche
3. **Tagga tutte le risorse** per tracking dei costi
4. **Monitora il Free Tier** tramite AWS Budgets
5. **Fai backup del terraform.tfstate** regolarmente (è salvato solo localmente)

## Troubleshooting

### Errore di inizializzazione
```bash
# Pulisci la cache e reinizializza
rm -rf .terraform/
terraform init
```

### State corrotto
Poiché lo state è locale, assicurati di:
- Fare backup regolari di `terraform.tfstate` e `terraform.tfstate.backup`
- Non modificare mai manualmente questi file

## Costi Stimati (Free Tier)

- VPC: Gratuito
- NAT Gateway: ~$0.045/ora (circa $32/mese con 1 AZ)
- EC2 (per ECS): t3.micro eligible per free tier
- Lambda: 1M richieste/mese gratuite
- DynamoDB: 25GB storage gratuito
- S3: 5GB storage gratuito

**Nota**: Il NAT Gateway è il costo principale. Per azzerare i costi durante lo sviluppo,
puoi distruggere l'infrastruttura quando non la usi:
```bash
terraform destroy  # fine giornata
terraform apply    # inizio lavoro
```



PATH: /elearning-platform/terraform/modules/cognito/lambda.tf

# Lambda function per Post Confirmation
resource "aws_lambda_function" "post_confirmation" {
  filename         = "${path.module}/lambda-functions/post-confirmation.zip"
  function_name    = "${var.project_name}-${var.environment}-post-confirmation"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "index.handler"
  runtime         = "nodejs18.x"
  timeout         = 10
  
  tags = {
    Name = "${var.project_name}-${var.environment}-post-confirmation"
  }
}

# Lambda function per Pre Authentication
resource "aws_lambda_function" "pre_authentication" {
  filename         = "${path.module}/lambda-functions/pre-authentication.zip"
  function_name    = "${var.project_name}-${var.environment}-pre-authentication"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "index.handler"
  runtime         = "nodejs18.x"
  timeout         = 10
  
  environment {
    variables = {
      PROJECT_NAME = var.project_name
      ENVIRONMENT  = var.environment
    }
  }
  
  tags = {
    Name = "${var.project_name}-${var.environment}-pre-authentication"
  }
}

# IAM Role per Lambda
resource "aws_iam_role" "lambda_execution_role" {
  name = "${var.project_name}-${var.environment}-cognito-lambda-role"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

# Policy per Lambda
resource "aws_iam_role_policy" "lambda_policy" {
  name = "${var.project_name}-${var.environment}-cognito-lambda-policy"
  role = aws_iam_role.lambda_execution_role.id
  
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = "arn:aws:logs:*:*:*"
      },
      {
        Effect = "Allow"
        Action = [
          "cognito-idp:AdminAddUserToGroup",
          "cognito-idp:AdminGetUser",
          "cognito-idp:AdminUpdateUserAttributes"
        ]
        Resource = aws_cognito_user_pool.main.arn
      }
    ]
  })
}

# Permessi per Cognito di invocare Lambda
resource "aws_lambda_permission" "post_confirmation" {
  statement_id  = "AllowExecutionFromCognito"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.post_confirmation.function_name
  principal     = "cognito-idp.amazonaws.com"
  source_arn    = aws_cognito_user_pool.main.arn
}

resource "aws_lambda_permission" "pre_authentication" {
  statement_id  = "AllowExecutionFromCognito"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.pre_authentication.function_name
  principal     = "cognito-idp.amazonaws.com"
  source_arn    = aws_cognito_user_pool.main.arn
}

# CloudWatch Log Groups
resource "aws_cloudwatch_log_group" "post_confirmation" {
  name              = "/aws/lambda/${aws_lambda_function.post_confirmation.function_name}"
  retention_in_days = 7
}

resource "aws_cloudwatch_log_group" "pre_authentication" {
  name              = "/aws/lambda/${aws_lambda_function.pre_authentication.function_name}"
  retention_in_days = 7
}

resource "aws_cloudwatch_log_group" "auth_logs" {
  name              = "/aws/lambda/${var.project_name}-${var.environment}-auth-logs"
  retention_in_days = 30
}




PATH: /elearning-platform/terraform/modules/cognito/main.tf

# User Pool Cognito
resource "aws_cognito_user_pool" "main" {
  name = "${var.project_name}-${var.environment}-user-pool"
  
  # Attributi richiesti
  username_attributes      = ["email"]
  auto_verified_attributes = ["email"]
  
  # Schema attributi
  schema {
    name                     = "email"
    attribute_data_type      = "String"
    required                 = true
    mutable                  = true
    developer_only_attribute = false
    
    string_attribute_constraints {
      min_length = 1
      max_length = 256
    }
  }
  
  schema {
    name                     = "name"
    attribute_data_type      = "String"
    required                 = true
    mutable                  = true
    developer_only_attribute = false
    
    string_attribute_constraints {
      min_length = 1
      max_length = 256
    }
  }
  
  schema {
    name                     = "family_name"
    attribute_data_type      = "String"
    required                 = true
    mutable                  = true
    developer_only_attribute = false
    
    string_attribute_constraints {
      min_length = 1
      max_length = 256
    }
  }
  
  # Attributo custom per il ruolo
  schema {
    name                     = "role"
    attribute_data_type      = "String"
    required                 = false
    mutable                  = true
    developer_only_attribute = false
    
    string_attribute_constraints {
      min_length = 1
      max_length = 256
    }
  }
  
  # Policy password
  password_policy {
    minimum_length                   = 8
    require_lowercase                = true
    require_uppercase                = true
    require_numbers                  = true
    require_symbols                  = true
    temporary_password_validity_days = 7
  }
  
  # MFA opzionale
  mfa_configuration = "OPTIONAL"
  
  software_token_mfa_configuration {
    enabled = true
  }
  
  # Configurazione account recovery
  account_recovery_setting {
    recovery_mechanism {
      name     = "verified_email"
      priority = 1
    }
  }
  
  # Email configuration
  email_configuration {
    email_sending_account = "COGNITO_DEFAULT"
  }
  
  # Lambda triggers
  lambda_config {
    post_confirmation = aws_lambda_function.post_confirmation.arn
    pre_authentication = aws_lambda_function.pre_authentication.arn
  }
  
  # Prevenzione cancellazione accidentale
  deletion_protection = var.environment == "prod" ? "ACTIVE" : "INACTIVE"
  
  tags = {
    Name = "${var.project_name}-${var.environment}-user-pool"
  }
}

# App Client per frontend
resource "aws_cognito_user_pool_client" "web_client" {
  name         = "${var.project_name}-${var.environment}-web-client"
  user_pool_id = aws_cognito_user_pool.main.id
  
  # Token configuration
  access_token_validity  = 1  # 1 ora
  id_token_validity      = 1  # 1 ora
  refresh_token_validity = 30 # 30 giorni
  
  token_validity_units {
    access_token  = "hours"
    id_token      = "hours"
    refresh_token = "days"
  }
  
  # # COMMENTATO TUTTO IL BLOCCO OAuth - NON SERVE per Auth.signIn()
  # # OAuth configuration
  # allowed_oauth_flows_user_pool_client = true
  # allowed_oauth_flows                  = ["code", "implicit"]
  # allowed_oauth_scopes                 = ["email", "openid", "profile"]
  
  # # Callback URLs (da aggiornare con URL reali) - NON PIU' NECESSARIE
  # callback_urls = [
  #   "http://localhost:3000/callback",
  #   "http://${var.domain_name}/callback",
  #   "https://${var.domain_name}/callback"
  # ]
  
  # logout_urls = [
  #   "http://localhost:3000/logout",
  #   "http://${var.domain_name}/logout",
  #   "https://${var.domain_name}/logout"
  # ]
  
  # Security
  prevent_user_existence_errors = "ENABLED"
  
  # Attributi leggibili/scrivibili
  read_attributes = [
    "email",
    "email_verified",
    "name",
    "family_name",
    "custom:role"
  ]
  
  write_attributes = [
    "email",
    "name",
    "family_name",
    "custom:role"
  ]
  
  explicit_auth_flows = [
    "ALLOW_USER_PASSWORD_AUTH",
    "ALLOW_REFRESH_TOKEN_AUTH",
    "ALLOW_USER_SRP_AUTH"
  ]
  
  generate_secret = false
}

# Gruppi Cognito
resource "aws_cognito_user_group" "docenti" {
  name         = "Docenti"
  user_pool_id = aws_cognito_user_pool.main.id
  description  = "Gruppo per i docenti"
  precedence   = 1
}

resource "aws_cognito_user_group" "studenti" {
  name         = "Studenti"
  user_pool_id = aws_cognito_user_pool.main.id
  description  = "Gruppo per gli studenti"
  precedence   = 2
}

# User Pool Domain
resource "aws_cognito_user_pool_domain" "main" {
  domain       = "${var.project_name}-${var.environment}-${random_string.domain_suffix.result}"
  user_pool_id = aws_cognito_user_pool.main.id
}

resource "random_string" "domain_suffix" {
  length  = 8
  special = false
  upper   = false
}



PATH: /elearning-platform/terraform/modules/cognito/outputs.tf

output "user_pool_id" {
  description = "ID del Cognito User Pool"
  value       = aws_cognito_user_pool.main.id
}

output "user_pool_arn" {
  description = "ARN del Cognito User Pool"
  value       = aws_cognito_user_pool.main.arn
}

output "user_pool_endpoint" {
  description = "Endpoint del Cognito User Pool"
  value       = aws_cognito_user_pool.main.endpoint
}

output "web_client_id" {
  description = "ID del client web Cognito"
  value       = aws_cognito_user_pool_client.web_client.id
}

output "user_pool_domain" {
  description = "Dominio del Cognito User Pool"
  value       = aws_cognito_user_pool_domain.main.domain
}


PATH: /elearning-platform/terraform/modules/cognito/variables.tf

variable "project_name" {
  description = "Nome del progetto"
  type        = string
}

variable "environment" {
  description = "Nome dell'ambiente"
  type        = string
}

# Rimosso non più necessario
# variable "domain_name" {
#   description = "Nome dominio per callback URLs"
#   type        = string
#   default     = "localhost:3000"
# }


PATH: /elearning-platform/terraform/modules/cognito/lambda-functions/post-confirmation/index.js

const { CognitoIdentityProviderClient, AdminAddUserToGroupCommand, AdminUpdateUserAttributesCommand } = require('@aws-sdk/client-cognito-identity-provider');
const cognito = new CognitoIdentityProviderClient();

exports.handler = async (event) => {
    console.log('Post Confirmation Trigger:', JSON.stringify(event, null, 2));
    
    const userPoolId = event.userPoolId;
    const username = event.userName;
    const userAttributes = event.request.userAttributes;
    
    try {
        // Determina il gruppo basandosi sull'attributo role
        const role = userAttributes['custom:role'] || 'studente';
        const groupName = role.toLowerCase() === 'docente' ? 'Docenti' : 'Studenti';
        
        // Aggiungi l'utente al gruppo appropriato
        const addToGroupCommand = new AdminAddUserToGroupCommand({
            GroupName: groupName,
            UserPoolId: userPoolId,
            Username: username
        });
        
        await cognito.send(addToGroupCommand);
        
        console.log(`User ${username} added to group ${groupName}`);
        
        // Aggiorna l'attributo role se non presente
        if (!userAttributes['custom:role']) {
            const updateAttributesCommand = new AdminUpdateUserAttributesCommand({
                UserPoolId: userPoolId,
                Username: username,
                UserAttributes: [
                    {
                        Name: 'custom:role',
                        Value: role
                    }
                ]
            });
            
            await cognito.send(updateAttributesCommand);
            console.log(`User ${username} role attribute updated to ${role}`);
        }
        
        return event;
        
    } catch (error) {
        console.error('Error in post confirmation trigger:', error);
        throw error;
    }
};


PATH: /elearning-platform/terraform/modules/cognito/lambda-functions/pre-authentication/index.js

const { CloudWatchLogsClient, CreateLogStreamCommand, PutLogEventsCommand } = require('@aws-sdk/client-cloudwatch-logs');
const cloudwatchlogs = new CloudWatchLogsClient();

exports.handler = async (event) => {
    console.log('Pre Authentication Trigger:', JSON.stringify(event, null, 2));
    
    const projectName = process.env.PROJECT_NAME || 'elearning';
    const environment = process.env.ENVIRONMENT || 'dev';
    const logGroupName = `/aws/lambda/${projectName}-${environment}-auth-logs`;
    
    const logStreamName = `auth-logs-${new Date().toISOString().split('T')[0]}`;
    const timestamp = Date.now();
    const username = event.userName;
    const userPoolId = event.userPoolId;
    
    try {
        // Log dell'accesso
        const logEntry = {
            timestamp: new Date().toISOString(),
            username: username,
            userPoolId: userPoolId,
            eventType: 'USER_AUTHENTICATION',
            sourceIp: event.request.userContextData?.sourceIp || 'unknown',
            deviceKey: event.request.userContextData?.deviceKey || 'unknown',
            success: true
        };
        
        // Verifica se il log stream esiste, altrimenti crealo
        try {
            const createLogStreamCommand = new CreateLogStreamCommand({
                logGroupName: logGroupName,
                logStreamName: logStreamName
            });
            await cloudwatchlogs.send(createLogStreamCommand);
        } catch (err) {
            // Il log stream potrebbe già esistere, non è un problema
            if (err.name !== 'ResourceAlreadyExistsException') {
                console.error('Error creating log stream:', err);
            }
        }
        
        // Invia il log
        const putLogEventsCommand = new PutLogEventsCommand({
            logGroupName: logGroupName,
            logStreamName: logStreamName,
            logEvents: [
                {
                    message: JSON.stringify(logEntry),
                    timestamp: timestamp
                }
            ]
        });
        
        await cloudwatchlogs.send(putLogEventsCommand);
        
        console.log(`Authentication logged for user ${username}`);
        
        // Ritorna l'evento per continuare il flusso di autenticazione
        return event;
        
    } catch (error) {
        console.error('Error in pre authentication trigger:', error);
        // Non bloccare l'autenticazione se il logging fallisce
        return event;
    }
};


PATH: /elearning-platform/terraform/modules/cognito/lambda-functions/README.md

# Cognito Lambda Triggers Setup

## Preparazione delle Lambda Functions

Prima di applicare il modulo Cognito, è necessario creare i file ZIP delle Lambda functions.

### Struttura richiesta:
```
lambda-functions/
├── post-confirmation/
│   └── index.js
├── pre-authentication/
│   └── index.js
├── post-confirmation.zip
└── pre-authentication.zip
```

### Passaggi:

1. **Crea le directory**:
   ```bash
   cd terraform/modules/cognito
   mkdir -p lambda-functions/post-confirmation
   mkdir -p lambda-functions/pre-authentication
   ```

2. **Copia i file JavaScript** dalle rispettive directory

3. **Crea i file ZIP**:
   ```bash
   cd lambda-functions/post-confirmation
   zip ../post-confirmation.zip index.js
   cd ../pre-authentication
   zip ../pre-authentication.zip index.js
   cd ../..
   ```

   O usa lo script fornito:
   ```bash
   chmod +x prepare-lambda.sh
   ./prepare-lambda.sh
   ```

## Funzionalità delle Lambda

### Post Confirmation
- Assegna automaticamente l'utente al gruppo appropriato (Docenti o Studenti)
- Basato sull'attributo custom `role` fornito durante la registrazione
- Default: assegna al gruppo "Studenti" se il ruolo non è specificato

### Pre Authentication
- Registra tutti i tentativi di autenticazione in CloudWatch Logs
- Traccia IP sorgente, device key, timestamp
- Utile per audit e sicurezza





PATH: /elearning-platform/terraform/modules/compute/api_cors.tf

# CORS configuration for all resources

# Helper for CORS integration response
locals {
  cors_headers = {
    "method.response.header.Access-Control-Allow-Headers" = "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
    "method.response.header.Access-Control-Allow-Methods" = "'GET,OPTIONS,POST,PUT,DELETE'"
    "method.response.header.Access-Control-Allow-Origin"  = "'*'"
  }
}

# /courses OPTIONS
resource "aws_api_gateway_method" "courses_options" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.courses.id
  http_method   = "OPTIONS"
  authorization = "NONE"
}

resource "aws_api_gateway_integration" "courses_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.courses.id
  http_method = aws_api_gateway_method.courses_options.http_method
  type        = "MOCK"
  
  request_templates = {
    "application/json" = "{\"statusCode\": 200}"
  }
}

resource "aws_api_gateway_method_response" "courses_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.courses.id
  http_method = aws_api_gateway_method.courses_options.http_method
  status_code = "200"
  
  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = true
    "method.response.header.Access-Control-Allow-Methods" = true
    "method.response.header.Access-Control-Allow-Origin"  = true
  }
}

resource "aws_api_gateway_integration_response" "courses_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.courses.id
  http_method = aws_api_gateway_method.courses_options.http_method
  status_code = aws_api_gateway_method_response.courses_options.status_code
  
  response_parameters = local.cors_headers
}

# /courses/{courseId} OPTIONS
resource "aws_api_gateway_method" "course_options" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.course.id
  http_method   = "OPTIONS"
  authorization = "NONE"
}

resource "aws_api_gateway_integration" "course_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.course.id
  http_method = aws_api_gateway_method.course_options.http_method
  type        = "MOCK"
  
  request_templates = {
    "application/json" = "{\"statusCode\": 200}"
  }
}

resource "aws_api_gateway_method_response" "course_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.course.id
  http_method = aws_api_gateway_method.course_options.http_method
  status_code = "200"
  
  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = true
    "method.response.header.Access-Control-Allow-Methods" = true
    "method.response.header.Access-Control-Allow-Origin"  = true
  }
}

resource "aws_api_gateway_integration_response" "course_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.course.id
  http_method = aws_api_gateway_method.course_options.http_method
  status_code = aws_api_gateway_method_response.course_options.status_code
  
  response_parameters = local.cors_headers
}

# /courses/{courseId}/enrollments OPTIONS
resource "aws_api_gateway_method" "enrollments_options" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.enrollments.id
  http_method   = "OPTIONS"
  authorization = "NONE"
}

resource "aws_api_gateway_integration" "enrollments_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.enrollments.id
  http_method = aws_api_gateway_method.enrollments_options.http_method
  type        = "MOCK"
  
  request_templates = {
    "application/json" = "{\"statusCode\": 200}"
  }
}

resource "aws_api_gateway_method_response" "enrollments_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.enrollments.id
  http_method = aws_api_gateway_method.enrollments_options.http_method
  status_code = "200"
  
  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = true
    "method.response.header.Access-Control-Allow-Methods" = true
    "method.response.header.Access-Control-Allow-Origin"  = true
  }
}

resource "aws_api_gateway_integration_response" "enrollments_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.enrollments.id
  http_method = aws_api_gateway_method.enrollments_options.http_method
  status_code = aws_api_gateway_method_response.enrollments_options.status_code
  
  response_parameters = local.cors_headers
}

# /courses/{courseId}/enrollments/{enrollmentId} OPTIONS
resource "aws_api_gateway_method" "enrollment_options" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.enrollment.id
  http_method   = "OPTIONS"
  authorization = "NONE"
}

resource "aws_api_gateway_integration" "enrollment_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.enrollment.id
  http_method = aws_api_gateway_method.enrollment_options.http_method
  type        = "MOCK"
  
  request_templates = {
    "application/json" = "{\"statusCode\": 200}"
  }
}

resource "aws_api_gateway_method_response" "enrollment_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.enrollment.id
  http_method = aws_api_gateway_method.enrollment_options.http_method
  status_code = "200"
  
  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = true
    "method.response.header.Access-Control-Allow-Methods" = true
    "method.response.header.Access-Control-Allow-Origin"  = true
  }
}

resource "aws_api_gateway_integration_response" "enrollment_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.enrollment.id
  http_method = aws_api_gateway_method.enrollment_options.http_method
  status_code = aws_api_gateway_method_response.enrollment_options.status_code
  
  response_parameters = local.cors_headers
}

# /courses/{courseId}/documents OPTIONS
resource "aws_api_gateway_method" "documents_options" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.documents.id
  http_method   = "OPTIONS"
  authorization = "NONE"
}

resource "aws_api_gateway_integration" "documents_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.documents.id
  http_method = aws_api_gateway_method.documents_options.http_method
  type        = "MOCK"
  
  request_templates = {
    "application/json" = "{\"statusCode\": 200}"
  }
}

resource "aws_api_gateway_method_response" "documents_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.documents.id
  http_method = aws_api_gateway_method.documents_options.http_method
  status_code = "200"
  
  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = true
    "method.response.header.Access-Control-Allow-Methods" = true
    "method.response.header.Access-Control-Allow-Origin"  = true
  }
}

resource "aws_api_gateway_integration_response" "documents_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.documents.id
  http_method = aws_api_gateway_method.documents_options.http_method
  status_code = aws_api_gateway_method_response.documents_options.status_code
  
  response_parameters = local.cors_headers
}

# /courses/{courseId}/documents/{documentId} OPTIONS
resource "aws_api_gateway_method" "document_options" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.document.id
  http_method   = "OPTIONS"
  authorization = "NONE"
}

resource "aws_api_gateway_integration" "document_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.document.id
  http_method = aws_api_gateway_method.document_options.http_method
  type        = "MOCK"
  
  request_templates = {
    "application/json" = "{\"statusCode\": 200}"
  }
}

resource "aws_api_gateway_method_response" "document_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.document.id
  http_method = aws_api_gateway_method.document_options.http_method
  status_code = "200"
  
  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = true
    "method.response.header.Access-Control-Allow-Methods" = true
    "method.response.header.Access-Control-Allow-Origin"  = true
  }
}

resource "aws_api_gateway_integration_response" "document_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.document.id
  http_method = aws_api_gateway_method.document_options.http_method
  status_code = aws_api_gateway_method_response.document_options.status_code
  
  response_parameters = local.cors_headers
}

# /courses/{courseId}/documents/{documentId}/quiz OPTIONS
resource "aws_api_gateway_method" "quiz_options" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.quiz.id
  http_method   = "OPTIONS"
  authorization = "NONE"
}

resource "aws_api_gateway_integration" "quiz_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.quiz.id
  http_method = aws_api_gateway_method.quiz_options.http_method
  type        = "MOCK"
  
  request_templates = {
    "application/json" = "{\"statusCode\": 200}"
  }
}

resource "aws_api_gateway_method_response" "quiz_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.quiz.id
  http_method = aws_api_gateway_method.quiz_options.http_method
  status_code = "200"
  
  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = true
    "method.response.header.Access-Control-Allow-Methods" = true
    "method.response.header.Access-Control-Allow-Origin"  = true
  }
}

resource "aws_api_gateway_integration_response" "quiz_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.quiz.id
  http_method = aws_api_gateway_method.quiz_options.http_method
  status_code = aws_api_gateway_method_response.quiz_options.status_code
  
  response_parameters = local.cors_headers
}

# /results OPTIONS
resource "aws_api_gateway_method" "results_options" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.results.id
  http_method   = "OPTIONS"
  authorization = "NONE"
}

resource "aws_api_gateway_integration" "results_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.results.id
  http_method = aws_api_gateway_method.results_options.http_method
  type        = "MOCK"
  
  request_templates = {
    "application/json" = "{\"statusCode\": 200}"
  }
}

resource "aws_api_gateway_method_response" "results_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.results.id
  http_method = aws_api_gateway_method.results_options.http_method
  status_code = "200"
  
  response_parameters = {
    "method.response.header.Access-Control-Allow-Headers" = true
    "method.response.header.Access-Control-Allow-Methods" = true
    "method.response.header.Access-Control-Allow-Origin"  = true
  }
}

resource "aws_api_gateway_integration_response" "results_options" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.results.id
  http_method = aws_api_gateway_method.results_options.http_method
  status_code = aws_api_gateway_method_response.results_options.status_code
  
  response_parameters = local.cors_headers
}




PATH: /elearning-platform/terraform/modules/compute/api_gateway_cors_fix.tf

# Enable CORS for the entire API
resource "aws_api_gateway_gateway_response" "response_4xx" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  response_type = "DEFAULT_4XX"

  response_templates = {
    "application/json" = "{\"message\":$context.error.messageString}"
  }

  response_parameters = {
    "gatewayresponse.header.Access-Control-Allow-Origin"  = "'*'"
    "gatewayresponse.header.Access-Control-Allow-Headers" = "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
    "gatewayresponse.header.Access-Control-Allow-Methods" = "'GET,OPTIONS,POST,PUT,DELETE'"
  }
}

resource "aws_api_gateway_gateway_response" "response_5xx" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  response_type = "DEFAULT_5XX"

  response_templates = {
    "application/json" = "{\"message\":$context.error.messageString}"
  }

  response_parameters = {
    "gatewayresponse.header.Access-Control-Allow-Origin"  = "'*'"
    "gatewayresponse.header.Access-Control-Allow-Headers" = "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
    "gatewayresponse.header.Access-Control-Allow-Methods" = "'GET,OPTIONS,POST,PUT,DELETE'"
  }
}





PATH: /elearning-platform/terraform/modules/compute/api_gateway.tf

# IAM Role per API Gateway CloudWatch Logs
resource "aws_iam_role" "api_gateway_cloudwatch" {
  name = "${var.project_name}-${var.environment}-api-gateway-cloudwatch-role"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "apigateway.amazonaws.com"
        }
      }
    ]
  })
}

resource "aws_iam_role_policy_attachment" "api_gateway_cloudwatch" {
  role       = aws_iam_role.api_gateway_cloudwatch.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs"
}

# API Gateway Account Settings
resource "aws_api_gateway_account" "main" {
  cloudwatch_role_arn = aws_iam_role.api_gateway_cloudwatch.arn
}

# API Gateway REST
resource "aws_api_gateway_rest_api" "main" {
  name        = "${var.project_name}-${var.environment}-api"
  description = "E-Learning Platform API"
  
  endpoint_configuration {
    types = ["REGIONAL"]
  }
}

# Cognito Authorizer
resource "aws_api_gateway_authorizer" "cognito" {
  name            = "${var.project_name}-${var.environment}-authorizer"
  rest_api_id     = aws_api_gateway_rest_api.main.id
  type            = "COGNITO_USER_POOLS"
  provider_arns   = [var.user_pool_arn]
  identity_source = "method.request.header.Authorization"
}

# ====================
# COURSES RESOURCES
# ====================

# /courses
resource "aws_api_gateway_resource" "courses" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  parent_id   = aws_api_gateway_rest_api.main.root_resource_id
  path_part   = "courses"
}

# GET /courses
resource "aws_api_gateway_method" "list_courses" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.courses.id
  http_method   = "GET"
  authorization = "COGNITO_USER_POOLS"
  authorizer_id = aws_api_gateway_authorizer.cognito.id
}

resource "aws_api_gateway_integration" "list_courses" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.courses.id
  http_method = aws_api_gateway_method.list_courses.http_method
  
  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.list_courses.invoke_arn
}

# POST /courses
resource "aws_api_gateway_method" "create_course" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.courses.id
  http_method   = "POST"
  authorization = "COGNITO_USER_POOLS"
  authorizer_id = aws_api_gateway_authorizer.cognito.id
}

resource "aws_api_gateway_integration" "create_course" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.courses.id
  http_method = aws_api_gateway_method.create_course.http_method
  
  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.create_course.invoke_arn
}

# /courses/{courseId}
resource "aws_api_gateway_resource" "course" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  parent_id   = aws_api_gateway_resource.courses.id
  path_part   = "{courseId}"
}

# GET /courses/{courseId}
resource "aws_api_gateway_method" "get_course" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.course.id
  http_method   = "GET"
  authorization = "COGNITO_USER_POOLS"
  authorizer_id = aws_api_gateway_authorizer.cognito.id
}

resource "aws_api_gateway_integration" "get_course" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.course.id
  http_method = aws_api_gateway_method.get_course.http_method
  
  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.manage_course.invoke_arn
}

# PUT /courses/{courseId}
resource "aws_api_gateway_method" "update_course" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.course.id
  http_method   = "PUT"
  authorization = "COGNITO_USER_POOLS"
  authorizer_id = aws_api_gateway_authorizer.cognito.id
}

resource "aws_api_gateway_integration" "update_course" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.course.id
  http_method = aws_api_gateway_method.update_course.http_method
  
  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.manage_course.invoke_arn
}

# DELETE /courses/{courseId}
resource "aws_api_gateway_method" "delete_course" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.course.id
  http_method   = "DELETE"
  authorization = "COGNITO_USER_POOLS"
  authorizer_id = aws_api_gateway_authorizer.cognito.id
}

resource "aws_api_gateway_integration" "delete_course" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.course.id
  http_method = aws_api_gateway_method.delete_course.http_method
  
  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.manage_course.invoke_arn
}

# ====================
# ENROLLMENTS RESOURCES
# ====================

# /courses/{courseId}/enrollments
resource "aws_api_gateway_resource" "enrollments" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  parent_id   = aws_api_gateway_resource.course.id
  path_part   = "enrollments"
}

# GET /courses/{courseId}/enrollments
resource "aws_api_gateway_method" "list_enrollments" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.enrollments.id
  http_method   = "GET"
  authorization = "COGNITO_USER_POOLS"
  authorizer_id = aws_api_gateway_authorizer.cognito.id
}

resource "aws_api_gateway_integration" "list_enrollments" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.enrollments.id
  http_method = aws_api_gateway_method.list_enrollments.http_method
  
  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.list_enrollments.invoke_arn
}

# POST /courses/{courseId}/enrollments
resource "aws_api_gateway_method" "request_enrollment" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.enrollments.id
  http_method   = "POST"
  authorization = "COGNITO_USER_POOLS"
  authorizer_id = aws_api_gateway_authorizer.cognito.id
}

resource "aws_api_gateway_integration" "request_enrollment" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.enrollments.id
  http_method = aws_api_gateway_method.request_enrollment.http_method
  
  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.request_enrollment.invoke_arn
}

# /courses/{courseId}/enrollments/{enrollmentId}
resource "aws_api_gateway_resource" "enrollment" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  parent_id   = aws_api_gateway_resource.enrollments.id
  path_part   = "{enrollmentId}"
}

# PUT /courses/{courseId}/enrollments/{enrollmentId}
resource "aws_api_gateway_method" "approve_enrollment" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.enrollment.id
  http_method   = "PUT"
  authorization = "COGNITO_USER_POOLS"
  authorizer_id = aws_api_gateway_authorizer.cognito.id
}

resource "aws_api_gateway_integration" "approve_enrollment" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.enrollment.id
  http_method = aws_api_gateway_method.approve_enrollment.http_method
  
  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.approve_enrollment.invoke_arn
}

# ====================
# DOCUMENTS RESOURCES
# ====================

# /courses/{courseId}/documents
resource "aws_api_gateway_resource" "documents" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  parent_id   = aws_api_gateway_resource.course.id
  path_part   = "documents"
}

# GET /courses/{courseId}/documents
resource "aws_api_gateway_method" "list_documents" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.documents.id
  http_method   = "GET"
  authorization = "COGNITO_USER_POOLS"
  authorizer_id = aws_api_gateway_authorizer.cognito.id
}

resource "aws_api_gateway_integration" "list_documents" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.documents.id
  http_method = aws_api_gateway_method.list_documents.http_method
  
  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.list_documents.invoke_arn
}

# POST /courses/{courseId}/documents
resource "aws_api_gateway_method" "get_upload_url" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.documents.id
  http_method   = "POST"
  authorization = "COGNITO_USER_POOLS"
  authorizer_id = aws_api_gateway_authorizer.cognito.id
}

resource "aws_api_gateway_integration" "get_upload_url" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.documents.id
  http_method = aws_api_gateway_method.get_upload_url.http_method
  
  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.get_presigned_url.invoke_arn
}

# /courses/{courseId}/documents/{documentId}
resource "aws_api_gateway_resource" "document" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  parent_id   = aws_api_gateway_resource.documents.id
  path_part   = "{documentId}"
}

# GET /courses/{courseId}/documents/{documentId}
resource "aws_api_gateway_method" "get_download_url" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.document.id
  http_method   = "GET"
  authorization = "COGNITO_USER_POOLS"
  authorizer_id = aws_api_gateway_authorizer.cognito.id
}

resource "aws_api_gateway_integration" "get_download_url" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.document.id
  http_method = aws_api_gateway_method.get_download_url.http_method
  
  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.manage_document.invoke_arn
}

# DELETE /courses/{courseId}/documents/{documentId}
resource "aws_api_gateway_method" "delete_document" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.document.id
  http_method   = "DELETE"
  authorization = "COGNITO_USER_POOLS"
  authorizer_id = aws_api_gateway_authorizer.cognito.id
}

resource "aws_api_gateway_integration" "delete_document" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.document.id
  http_method = aws_api_gateway_method.delete_document.http_method
  
  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.manage_document.invoke_arn
}

# ====================
# QUIZ RESOURCES
# ====================

# /courses/{courseId}/documents/{documentId}/quiz
resource "aws_api_gateway_resource" "quiz" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  parent_id   = aws_api_gateway_resource.document.id
  path_part   = "quiz"
}

# GET /courses/{courseId}/documents/{documentId}/quiz
resource "aws_api_gateway_method" "get_quiz" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.quiz.id
  http_method   = "GET"
  authorization = "COGNITO_USER_POOLS"
  authorizer_id = aws_api_gateway_authorizer.cognito.id
}

resource "aws_api_gateway_integration" "get_quiz" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.quiz.id
  http_method = aws_api_gateway_method.get_quiz.http_method
  
  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.get_quiz.invoke_arn
}

# POST /courses/{courseId}/documents/{documentId}/quiz
resource "aws_api_gateway_method" "submit_quiz" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.quiz.id
  http_method   = "POST"
  authorization = "COGNITO_USER_POOLS"
  authorizer_id = aws_api_gateway_authorizer.cognito.id
}

resource "aws_api_gateway_integration" "submit_quiz" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.quiz.id
  http_method = aws_api_gateway_method.submit_quiz.http_method
  
  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.submit_quiz_results.invoke_arn
}

# ====================
# RESULTS RESOURCES
# ====================

# /results
resource "aws_api_gateway_resource" "results" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  parent_id   = aws_api_gateway_rest_api.main.root_resource_id
  path_part   = "results"
}

# GET /results
resource "aws_api_gateway_method" "list_results" {
  rest_api_id   = aws_api_gateway_rest_api.main.id
  resource_id   = aws_api_gateway_resource.results.id
  http_method   = "GET"
  authorization = "COGNITO_USER_POOLS"
  authorizer_id = aws_api_gateway_authorizer.cognito.id
}

resource "aws_api_gateway_integration" "list_results" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  resource_id = aws_api_gateway_resource.results.id
  http_method = aws_api_gateway_method.list_results.http_method
  
  integration_http_method = "POST"
  type                    = "AWS_PROXY"
  uri                     = aws_lambda_function.list_results.invoke_arn
}

# ====================
# API DEPLOYMENT
# ====================

resource "aws_api_gateway_deployment" "main" {
  rest_api_id = aws_api_gateway_rest_api.main.id
  
  depends_on = [
    aws_api_gateway_integration.list_courses,
    aws_api_gateway_integration.create_course,
    aws_api_gateway_integration.get_course,
    aws_api_gateway_integration.update_course,
    aws_api_gateway_integration.delete_course,
    aws_api_gateway_integration.list_enrollments,
    aws_api_gateway_integration.request_enrollment,
    aws_api_gateway_integration.approve_enrollment,
    aws_api_gateway_integration.list_documents,
    aws_api_gateway_integration.get_upload_url,
    aws_api_gateway_integration.get_download_url,
    aws_api_gateway_integration.delete_document,
    aws_api_gateway_integration.get_quiz,
    aws_api_gateway_integration.submit_quiz,
    aws_api_gateway_integration.list_results,
    # CORS OPTIONS integrations
    aws_api_gateway_integration.courses_options,
    aws_api_gateway_integration.course_options,
    aws_api_gateway_integration.enrollments_options,
    aws_api_gateway_integration.enrollment_options,
    aws_api_gateway_integration.documents_options,
    aws_api_gateway_integration.document_options,
    aws_api_gateway_integration.quiz_options,
    aws_api_gateway_integration.results_options
  ]
  
  lifecycle {
    create_before_destroy = true
  }
}

resource "aws_api_gateway_stage" "main" {
  deployment_id = aws_api_gateway_deployment.main.id
  rest_api_id   = aws_api_gateway_rest_api.main.id
  stage_name    = var.environment
  
  xray_tracing_enabled = false  # Può essere abilitato per debugging
  
  access_log_settings {
    destination_arn = aws_cloudwatch_log_group.api_gateway_logs.arn
    format = jsonencode({
      requestId      = "$context.requestId"
      requestTime    = "$context.requestTime"
      httpMethod     = "$context.httpMethod"
      resourcePath   = "$context.resourcePath"
      status         = "$context.status"
      responseLength = "$context.responseLength"
      error          = "$context.error.message"
    })
  }
  
  depends_on = [aws_api_gateway_account.main]
}

resource "aws_cloudwatch_log_group" "api_gateway_logs" {
  name              = "/aws/apigateway/${var.project_name}-${var.environment}"
  retention_in_days = 7
}

# Resource policy per permettere ad API Gateway di scrivere nei log
resource "aws_cloudwatch_log_resource_policy" "api_gateway_logs" {
  policy_name = "${var.project_name}-${var.environment}-api-gateway-logs-policy"
  
  policy_document = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          Service = "apigateway.amazonaws.com"
        }
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:DescribeLogGroups",
          "logs:DescribeLogStreams",
          "logs:PutLogEvents",
          "logs:GetLogEvents",
          "logs:FilterLogEvents"
        ]
        Resource = "arn:aws:logs:*:*:*"
      }
    ]
  })
}

# Lambda permissions per API Gateway
resource "aws_lambda_permission" "api_gateway_lambda" {
  for_each = {
    create_course       = aws_lambda_function.create_course.function_name
    list_courses        = aws_lambda_function.list_courses.function_name
    manage_course       = aws_lambda_function.manage_course.function_name
    request_enrollment  = aws_lambda_function.request_enrollment.function_name
    approve_enrollment  = aws_lambda_function.approve_enrollment.function_name
    list_enrollments    = aws_lambda_function.list_enrollments.function_name
    get_presigned_url   = aws_lambda_function.get_presigned_url.function_name
    list_documents      = aws_lambda_function.list_documents.function_name
    manage_document     = aws_lambda_function.manage_document.function_name
    get_quiz           = aws_lambda_function.get_quiz.function_name
    submit_quiz_results = aws_lambda_function.submit_quiz_results.function_name
    list_results       = aws_lambda_function.list_results.function_name
  }
  
  statement_id  = "AllowAPIGatewayInvoke"
  action        = "lambda:InvokeFunction"
  function_name = each.value
  principal     = "apigateway.amazonaws.com"
  source_arn    = "${aws_api_gateway_rest_api.main.execution_arn}/*/*"
}


PATH: /elearning-platform/terraform/modules/compute/lambda_courses.tf

# Lambda: Create Course
resource "aws_lambda_function" "create_course" {
  filename         = "${path.module}/functions/create-course.zip"
  function_name    = "${var.project_name}-${var.environment}-create-course"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "index.handler"
  # runtime         = "nodejs18.x"
  runtime         = "nodejs16.x"
  timeout         = 30
  memory_size     = 256
  
  layers = [aws_lambda_layer_version.shared_layer.arn]
  
  environment {
    variables = {
      COURSES_TABLE    = var.courses_table_name
      USER_POOL_ID     = var.user_pool_id
    }
  }
  
  source_code_hash = filebase64sha256("${path.module}/functions/create-course.zip")
  
  tags = {
    Name = "${var.project_name}-${var.environment}-create-course"
  }
}

# Lambda: List Courses
resource "aws_lambda_function" "list_courses" {
  filename         = "${path.module}/functions/list-courses.zip"
  function_name    = "${var.project_name}-${var.environment}-list-courses"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "index.handler"
  # runtime         = "nodejs18.x"
  runtime         = "nodejs16.x"
  timeout         = 30
  memory_size     = 256
  
  layers = [aws_lambda_layer_version.shared_layer.arn]
  
  environment {
    variables = {
      COURSES_TABLE     = var.courses_table_name
      ENROLLMENTS_TABLE = var.enrollments_table_name
      USER_POOL_ID      = var.user_pool_id
    }
  }
  
  source_code_hash = filebase64sha256("${path.module}/functions/list-courses.zip")
  
  tags = {
    Name = "${var.project_name}-${var.environment}-list-courses"
  }
}

# Lambda: Manage Course (Get/Update/Delete)
resource "aws_lambda_function" "manage_course" {
  filename         = "${path.module}/functions/manage-course.zip"
  function_name    = "${var.project_name}-${var.environment}-manage-course"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "index.handler"
  # runtime         = "nodejs18.x"
  runtime         = "nodejs16.x"
  timeout         = 30
  memory_size     = 256
  
  layers = [aws_lambda_layer_version.shared_layer.arn]
  
  environment {
    variables = {
      COURSES_TABLE = var.courses_table_name
      USER_POOL_ID  = var.user_pool_id
    }
  }
  
  source_code_hash = filebase64sha256("${path.module}/functions/manage-course.zip")
  
  tags = {
    Name = "${var.project_name}-${var.environment}-manage-course"
  }
}

# CloudWatch Log Groups per Lambda
resource "aws_cloudwatch_log_group" "create_course_logs" {
  name              = "/aws/lambda/${aws_lambda_function.create_course.function_name}"
  retention_in_days = 7
}

resource "aws_cloudwatch_log_group" "list_courses_logs" {
  name              = "/aws/lambda/${aws_lambda_function.list_courses.function_name}"
  retention_in_days = 7
}

resource "aws_cloudwatch_log_group" "manage_course_logs" {
  name              = "/aws/lambda/${aws_lambda_function.manage_course.function_name}"
  retention_in_days = 7
}


PATH: /elearning-platform/terraform/modules/compute/lambda_documents.tf

# Lambda: Get Presigned URL
resource "aws_lambda_function" "get_presigned_url" {
  filename         = "${path.module}/functions/get-presigned-url.zip"
  function_name    = "${var.project_name}-${var.environment}-get-presigned-url"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "index.handler"
  # runtime         = "nodejs18.x"
  runtime         = "nodejs16.x"
  timeout         = 30
  memory_size     = 256
  
  layers = [aws_lambda_layer_version.shared_layer.arn]
  
  environment {
    variables = {
      DOCUMENTS_BUCKET  = var.documents_bucket_name
      DOCUMENTS_TABLE   = var.documents_table_name
      COURSES_TABLE     = var.courses_table_name
      USER_POOL_ID      = var.user_pool_id
    }
  }
  
  source_code_hash = filebase64sha256("${path.module}/functions/get-presigned-url.zip")
  
  tags = {
    Name = "${var.project_name}-${var.environment}-get-presigned-url"
  }
}

# Lambda: List Documents
resource "aws_lambda_function" "list_documents" {
  filename         = "${path.module}/functions/list-documents.zip"
  function_name    = "${var.project_name}-${var.environment}-list-documents"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "index.handler"
  # runtime         = "nodejs18.x"
  runtime         = "nodejs16.x"
  timeout         = 30
  memory_size     = 256
  
  layers = [aws_lambda_layer_version.shared_layer.arn]
  
  environment {
    variables = {
      DOCUMENTS_TABLE   = var.documents_table_name
      ENROLLMENTS_TABLE = var.enrollments_table_name
      USER_POOL_ID      = var.user_pool_id
      COURSES_TABLE     = var.courses_table_name
    }
  }
  
  source_code_hash = filebase64sha256("${path.module}/functions/list-documents.zip")
  
  tags = {
    Name = "${var.project_name}-${var.environment}-list-documents"
  }
}

# Lambda: Manage Document
resource "aws_lambda_function" "manage_document" {
  filename         = "${path.module}/functions/manage-document.zip"
  function_name    = "${var.project_name}-${var.environment}-manage-document"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "index.handler"
  # runtime         = "nodejs18.x"
  runtime         = "nodejs16.x"
  timeout         = 30
  memory_size     = 256
  
  layers = [aws_lambda_layer_version.shared_layer.arn]
  
  environment {
    variables = {
      DOCUMENTS_TABLE   = var.documents_table_name
      DOCUMENTS_BUCKET  = var.documents_bucket_name
      COURSES_TABLE     = var.courses_table_name
      QUIZZES_TABLE     = var.quizzes_table_name
      USER_POOL_ID      = var.user_pool_id
      ENROLLMENTS_TABLE = var.enrollments_table_name
    }
  }
  
  source_code_hash = filebase64sha256("${path.module}/functions/manage-document.zip")
  
  tags = {
    Name = "${var.project_name}-${var.environment}-manage-document"
  }
}

# Lambda: Get Quiz
resource "aws_lambda_function" "get_quiz" {
  filename         = "${path.module}/functions/get-quiz.zip"
  function_name    = "${var.project_name}-${var.environment}-get-quiz"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "index.handler"
  # runtime         = "nodejs18.x"
  runtime         = "nodejs16.x"
  timeout         = 30
  memory_size     = 256
  
  layers = [aws_lambda_layer_version.shared_layer.arn]
  
  environment {
    variables = {
      QUIZZES_TABLE     = var.quizzes_table_name
      DOCUMENTS_TABLE   = var.documents_table_name
      ENROLLMENTS_TABLE = var.enrollments_table_name
      USER_POOL_ID      = var.user_pool_id
    }
  }
  
  source_code_hash = filebase64sha256("${path.module}/functions/get-quiz.zip")
  
  tags = {
    Name = "${var.project_name}-${var.environment}-get-quiz"
  }
}

# Lambda: Submit Quiz Results
resource "aws_lambda_function" "submit_quiz_results" {
  filename         = "${path.module}/functions/submit-quiz-results.zip"
  function_name    = "${var.project_name}-${var.environment}-submit-quiz-results"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "index.handler"
  # runtime         = "nodejs18.x"
  runtime         = "nodejs16.x"
  timeout         = 30
  memory_size     = 256
  
  layers = [aws_lambda_layer_version.shared_layer.arn]
  
  environment {
    variables = {
      RESULTS_TABLE     = var.results_table_name
      QUIZZES_TABLE     = var.quizzes_table_name
      ENROLLMENTS_TABLE = var.enrollments_table_name
      USER_POOL_ID      = var.user_pool_id
    }
  }
  
  source_code_hash = filebase64sha256("${path.module}/functions/submit-quiz-results.zip")
  
  tags = {
    Name = "${var.project_name}-${var.environment}-submit-quiz-results"
  }
}

# Lambda: List Results
resource "aws_lambda_function" "list_results" {
  filename         = "${path.module}/functions/list-results.zip"
  function_name    = "${var.project_name}-${var.environment}-list-results"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "index.handler"
  # runtime         = "nodejs18.x"
  runtime         = "nodejs16.x"
  timeout         = 30
  memory_size     = 256
  
  layers = [aws_lambda_layer_version.shared_layer.arn]
  
  environment {
    variables = {
      RESULTS_TABLE = var.results_table_name
      USER_POOL_ID  = var.user_pool_id
    }
  }
  
  source_code_hash = filebase64sha256("${path.module}/functions/list-results.zip")
  
  tags = {
    Name = "${var.project_name}-${var.environment}-list-results"
  }
}

# CloudWatch Log Groups
resource "aws_cloudwatch_log_group" "get_presigned_url_logs" {
  name              = "/aws/lambda/${aws_lambda_function.get_presigned_url.function_name}"
  retention_in_days = 7
}

resource "aws_cloudwatch_log_group" "list_documents_logs" {
  name              = "/aws/lambda/${aws_lambda_function.list_documents.function_name}"
  retention_in_days = 7
}

resource "aws_cloudwatch_log_group" "manage_document_logs" {
  name              = "/aws/lambda/${aws_lambda_function.manage_document.function_name}"
  retention_in_days = 7
}

resource "aws_cloudwatch_log_group" "get_quiz_logs" {
  name              = "/aws/lambda/${aws_lambda_function.get_quiz.function_name}"
  retention_in_days = 7
}

resource "aws_cloudwatch_log_group" "submit_quiz_results_logs" {
  name              = "/aws/lambda/${aws_lambda_function.submit_quiz_results.function_name}"
  retention_in_days = 7
}

resource "aws_cloudwatch_log_group" "list_results_logs" {
  name              = "/aws/lambda/${aws_lambda_function.list_results.function_name}"
  retention_in_days = 7
}


PATH: /elearning-platform/terraform/modules/compute/lambda_enrollments.tf

# Lambda: Request Enrollment
resource "aws_lambda_function" "request_enrollment" {
  filename         = "${path.module}/functions/request-enrollment.zip"
  function_name    = "${var.project_name}-${var.environment}-request-enrollment"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "index.handler"
  # runtime         = "nodejs18.x"
  runtime         = "nodejs16.x"
  timeout         = 30
  memory_size     = 256
  
  layers = [aws_lambda_layer_version.shared_layer.arn]
  
  environment {
    variables = {
      ENROLLMENTS_TABLE = var.enrollments_table_name
      COURSES_TABLE     = var.courses_table_name
      USER_POOL_ID      = var.user_pool_id
      SNS_TOPIC_ARN     = var.enrollment_notification_topic_arn
    }
  }
  
  source_code_hash = filebase64sha256("${path.module}/functions/request-enrollment.zip")
  
  tags = {
    Name = "${var.project_name}-${var.environment}-request-enrollment"
  }
}

# Lambda: Approve Enrollment
resource "aws_lambda_function" "approve_enrollment" {
  filename         = "${path.module}/functions/approve-enrollment.zip"
  function_name    = "${var.project_name}-${var.environment}-approve-enrollment"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "index.handler"
  # runtime         = "nodejs18.x"
  runtime         = "nodejs16.x"
  timeout         = 30
  memory_size     = 256
  
  layers = [aws_lambda_layer_version.shared_layer.arn]
  
  environment {
    variables = {
      ENROLLMENTS_TABLE = var.enrollments_table_name
      COURSES_TABLE     = var.courses_table_name
      USER_POOL_ID      = var.user_pool_id
    }
  }
  
  source_code_hash = filebase64sha256("${path.module}/functions/approve-enrollment.zip")
  
  tags = {
    Name = "${var.project_name}-${var.environment}-approve-enrollment"
  }
}

# Lambda: List Enrollments
resource "aws_lambda_function" "list_enrollments" {
  filename         = "${path.module}/functions/list-enrollments.zip"
  function_name    = "${var.project_name}-${var.environment}-list-enrollments"
  role            = aws_iam_role.lambda_execution_role.arn
  handler         = "index.handler"
  # runtime         = "nodejs18.x"
  runtime         = "nodejs16.x"
  timeout         = 30
  memory_size     = 256
  
  layers = [aws_lambda_layer_version.shared_layer.arn]
  
  environment {
    variables = {
      ENROLLMENTS_TABLE = var.enrollments_table_name
      USER_POOL_ID      = var.user_pool_id
      COURSES_TABLE     = var.courses_table_name
    }
  }
  
  source_code_hash = filebase64sha256("${path.module}/functions/list-enrollments.zip")
  
  tags = {
    Name = "${var.project_name}-${var.environment}-list-enrollments"
  }
}

# CloudWatch Log Groups
resource "aws_cloudwatch_log_group" "request_enrollment_logs" {
  name              = "/aws/lambda/${aws_lambda_function.request_enrollment.function_name}"
  retention_in_days = 7
}

resource "aws_cloudwatch_log_group" "approve_enrollment_logs" {
  name              = "/aws/lambda/${aws_lambda_function.approve_enrollment.function_name}"
  retention_in_days = 7
}

resource "aws_cloudwatch_log_group" "list_enrollments_logs" {
  name              = "/aws/lambda/${aws_lambda_function.list_enrollments.function_name}"
  retention_in_days = 7
}

# IAM Policy aggiuntiva per SNS - sempre creata ma con statement condizionale
resource "aws_iam_role_policy" "lambda_sns_policy" {
  name = "${var.project_name}-${var.environment}-lambda-sns-policy"
  role = aws_iam_role.lambda_execution_role.id
  
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "sns:Publish"
        ]
        Resource = var.enrollment_notification_topic_arn != "" ? var.enrollment_notification_topic_arn : "arn:aws:sns:*:*:non-existent-topic"
      }
    ]
  })
}


PATH: /elearning-platform/terraform/modules/compute/lambda_layer.tf

# Lambda Layer per utility functions condivise
resource "aws_lambda_layer_version" "shared_layer" {
  filename            = "${path.module}/layers/shared-layer.zip"
  layer_name          = "${var.project_name}-${var.environment}-shared-layer"
  # compatible_runtimes = ["nodejs18.x"]
  compatible_runtimes = ["nodejs16.x"]
  description         = "Shared utilities for Lambda functions"
  
  source_code_hash = filebase64sha256("${path.module}/layers/shared-layer.zip")
}

# IAM Role per tutte le Lambda functions
resource "aws_iam_role" "lambda_execution_role" {
  name = "${var.project_name}-${var.environment}-lambda-execution-role"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

# Policy per Lambda execution
resource "aws_iam_role_policy" "lambda_execution_policy" {
  name = "${var.project_name}-${var.environment}-lambda-execution-policy"
  role = aws_iam_role.lambda_execution_role.id
  
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = "arn:aws:logs:*:*:*"
      },
      {
        Effect = "Allow"
        Action = [
          "dynamodb:GetItem",
          "dynamodb:PutItem",
          "dynamodb:UpdateItem",
          "dynamodb:DeleteItem",
          "dynamodb:Query",
          "dynamodb:Scan",
          "dynamodb:BatchGetItem",
          "dynamodb:BatchWriteItem"
        ]
        Resource = [
          var.courses_table_arn,
          var.enrollments_table_arn,
          var.documents_table_arn,
          var.quizzes_table_arn,
          var.results_table_arn,
          "${var.courses_table_arn}/index/*",
          "${var.enrollments_table_arn}/index/*",
          "${var.results_table_arn}/index/*"
        ]
      },
      {
        Effect = "Allow"
        Action = [
          "s3:GetObject",
          "s3:PutObject",
          "s3:DeleteObject",
          "s3:GetObjectVersion"
        ]
        Resource = "${var.documents_bucket_arn}/*"
      },
      {
        Effect = "Allow"
        Action = [
          "s3:ListBucket"
        ]
        Resource = var.documents_bucket_arn
      },
      {
        Effect = "Allow"
        Action = [
          "cognito-idp:AdminGetUser",
          "cognito-idp:ListUsersInGroup"
        ]
        Resource = var.user_pool_arn
      }
    ]
  })
}

# Policy aggiuntiva per Lambda in VPC
resource "aws_iam_role_policy_attachment" "lambda_vpc_execution" {
  role       = aws_iam_role.lambda_execution_role.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole"
}



PATH: /elearning-platform/terraform/modules/compute/outputs.tf

# API Gateway
output "api_gateway_id" {
  description = "ID dell'API Gateway"
  value       = aws_api_gateway_rest_api.main.id
}

output "api_gateway_invoke_url" {
  description = "URL di invocazione dell'API Gateway"
  value       = aws_api_gateway_stage.main.invoke_url
}

output "api_gateway_stage_name" {
  description = "Nome dello stage API Gateway"
  value       = aws_api_gateway_stage.main.stage_name
}

# Lambda Functions ARNs
output "lambda_functions" {
  description = "ARNs delle Lambda functions"
  value = {
    create_course       = aws_lambda_function.create_course.arn
    list_courses        = aws_lambda_function.list_courses.arn
    manage_course       = aws_lambda_function.manage_course.arn
    request_enrollment  = aws_lambda_function.request_enrollment.arn
    approve_enrollment  = aws_lambda_function.approve_enrollment.arn
    list_enrollments    = aws_lambda_function.list_enrollments.arn
    get_presigned_url   = aws_lambda_function.get_presigned_url.arn
    list_documents      = aws_lambda_function.list_documents.arn
    manage_document     = aws_lambda_function.manage_document.arn
    get_quiz           = aws_lambda_function.get_quiz.arn
    submit_quiz_results = aws_lambda_function.submit_quiz_results.arn
    list_results       = aws_lambda_function.list_results.arn
  }
}

# Lambda Layer
output "shared_layer_arn" {
  description = "ARN del Lambda Layer condiviso"
  value       = aws_lambda_layer_version.shared_layer.arn
}

# IAM Role
output "lambda_execution_role_arn" {
  description = "ARN del ruolo IAM per le Lambda functions"
  value       = aws_iam_role.lambda_execution_role.arn
}


PATH: /elearning-platform/terraform/modules/compute/variables.tf

variable "project_name" {
  description = "Nome del progetto"
  type        = string
}

variable "environment" {
  description = "Nome dell'ambiente"
  type        = string
}

# Cognito
variable "user_pool_id" {
  description = "ID del Cognito User Pool"
  type        = string
}

variable "user_pool_arn" {
  description = "ARN del Cognito User Pool"
  type        = string
}

# DynamoDB Tables
variable "courses_table_name" {
  description = "Nome della tabella DynamoDB Courses"
  type        = string
}

variable "courses_table_arn" {
  description = "ARN della tabella DynamoDB Courses"
  type        = string
}

variable "enrollments_table_name" {
  description = "Nome della tabella DynamoDB Enrollments"
  type        = string
}

variable "enrollments_table_arn" {
  description = "ARN della tabella DynamoDB Enrollments"
  type        = string
}

variable "documents_table_name" {
  description = "Nome della tabella DynamoDB Documents"
  type        = string
}

variable "documents_table_arn" {
  description = "ARN della tabella DynamoDB Documents"
  type        = string
}

variable "quizzes_table_name" {
  description = "Nome della tabella DynamoDB Quizzes"
  type        = string
}

variable "quizzes_table_arn" {
  description = "ARN della tabella DynamoDB Quizzes"
  type        = string
}

variable "results_table_name" {
  description = "Nome della tabella DynamoDB Results"
  type        = string
}

variable "results_table_arn" {
  description = "ARN della tabella DynamoDB Results"
  type        = string
}

# S3 Buckets
variable "documents_bucket_name" {
  description = "Nome del bucket S3 per i documenti"
  type        = string
}

variable "documents_bucket_arn" {
  description = "ARN del bucket S3 per i documenti"
  type        = string
}

# SNS Topic (opzionale per ora)
variable "enrollment_notification_topic_arn" {
  description = "ARN del topic SNS per notifiche enrollment"
  type        = string
  default     = ""
}


PATH: /elearning-platform/terraform/modules/compute/README.md

# Compute Module - Lambda Functions e API Gateway

## Struttura

```
compute/
├── lambda_layer.tf         # Lambda Layer condiviso
├── lambda_courses.tf       # Functions per gestione corsi
├── lambda_enrollments.tf   # Functions per gestione iscrizioni
├── lambda_documents.tf     # Functions per documenti e quiz
├── api_gateway.tf         # API Gateway REST configuration
├── variables.tf
├── outputs.tf
├── layers/
│   └── shared/
│       └── nodejs/
│           └── utils.js   # Utility functions condivise
└── functions/
    ├── create-course/
    │   └── index.js
    ├── list-courses/
    │   └── index.js
    ├── manage-course/
    │   └── index.js
    └── ... (altre functions)
```

## Lambda Functions

### 1. Course Management
- **create-course**: Crea un nuovo corso (solo docenti)
- **list-courses**: Lista corsi (filtrati per ruolo)
- **manage-course**: GET/PUT/DELETE per singolo corso

### 2. Enrollment Management
- **request-enrollment**: Richiesta iscrizione (studenti)
- **approve-enrollment**: Approva/rifiuta iscrizione (docenti)
- **list-enrollments**: Lista iscrizioni per corso

### 3. Document Management
- **get-presigned-url**: Genera URL per upload/download
- **list-documents**: Lista documenti del corso
- **manage-document**: Gestisce singolo documento

### 4. Quiz Management
- **get-quiz**: Recupera quiz per documento
- **submit-quiz-results**: Invia risultati quiz

### 5. Results
- **list-results**: Lista risultati quiz dello studente

## API Endpoints

Tutti gli endpoint richiedono autenticazione tramite Cognito token nell'header:
```
Authorization: Bearer <cognito-id-token>
```

### Courses
- `GET /courses` - Lista corsi
- `POST /courses` - Crea corso
- `GET /courses/{courseId}` - Dettagli corso
- `PUT /courses/{courseId}` - Aggiorna corso
- `DELETE /courses/{courseId}` - Elimina corso

### Enrollments
- `GET /courses/{courseId}/enrollments` - Lista iscrizioni
- `POST /courses/{courseId}/enrollments` - Richiedi iscrizione
- `PUT /courses/{courseId}/enrollments/{enrollmentId}` - Approva/rifiuta

### Documents
- `GET /courses/{courseId}/documents` - Lista documenti
- `POST /courses/{courseId}/documents` - Ottieni upload URL
- `GET /courses/{courseId}/documents/{documentId}` - Download URL
- `DELETE /courses/{courseId}/documents/{documentId}` - Elimina documento

### Quiz
- `GET /courses/{courseId}/documents/{documentId}/quiz` - Ottieni quiz
- `POST /courses/{courseId}/documents/{documentId}/quiz` - Invia risultati

### Results
- `GET /results` - Lista risultati studente

## Preparazione Functions

Prima del deployment, esegui:
```bash
cd terraform/modules/compute
chmod +x prepare-lambda-functions.sh
./prepare-lambda-functions.sh
```

## Test con cURL

Esempio di test (sostituisci con i tuoi valori):
```bash
# Ottieni token da Cognito (implementa autenticazione)
TOKEN="your-cognito-id-token"
API_URL="https://your-api-id.execute-api.us-east-1.amazonaws.com/dev"

# Lista corsi
curl -H "Authorization: Bearer $TOKEN" \
     "$API_URL/courses"

# Crea corso (solo docenti)
curl -X POST \
     -H "Authorization: Bearer $TOKEN" \
     -H "Content-Type: application/json" \
     -d '{"name":"Matematica 101","description":"Corso base di matematica"}' \
     "$API_URL/courses"
```

## Note Implementative

1. **Autorizzazione**: 
   - I gruppi Cognito determinano i permessi (Docenti/Studenti)
   - Ownership check per update/delete

2. **Error Handling**:
   - 400: Bad Request (parametri mancanti)
   - 403: Forbidden (permessi insufficienti)
   - 404: Not Found
   - 500: Internal Server Error

3. **Performance**:
   - Lambda Layer riduce cold start
   - DynamoDB on-demand scaling
   - API Gateway caching (opzionale)

## Costi Stimati (Free Tier)

- Lambda: 1M richieste/mese gratuite
- API Gateway: 1M chiamate/mese gratuite (primo anno)
- CloudWatch Logs: 5GB gratuite


PATH: /elearning-platform/terraform/modules/compute/functions/approve-enrollment/index.js

const { 
    createResponse, 
    getUserInfo,
    isOwner,
    dynamodb 
} = require('/opt/nodejs/utils');

const ENROLLMENTS_TABLE = process.env.ENROLLMENTS_TABLE;
const COURSES_TABLE = process.env.COURSES_TABLE;

exports.handler = async (event) => {
    console.log('Event:', JSON.stringify(event, null, 2));
    
    try {
        const courseId = event.pathParameters.courseId;
        const enrollmentId = event.pathParameters.enrollmentId; // studentId
        const userInfo = await getUserInfo(event);
        const body = JSON.parse(event.body);
        
        // Validate action
        if (!body.action || !['approve', 'reject'].includes(body.action)) {
            return createResponse(400, {
                error: 'Bad Request',
                message: 'Action must be either "approve" or "reject"'
            });
        }
        
        // Check if user owns the course
        const owner = await isOwner(courseId, userInfo.username, COURSES_TABLE);
        
        if (!owner) {
            return createResponse(403, {
                error: 'Forbidden',
                message: 'Only the course owner can approve enrollments'
            });
        }
        
        // Get enrollment
        const getParams = {
            TableName: ENROLLMENTS_TABLE,
            Key: {
                studentId: enrollmentId,
                courseId: courseId
            }
        };
        
        const result = await dynamodb.get(getParams).promise();
        
        if (!result.Item) {
            return createResponse(404, {
                error: 'Not Found',
                message: 'Enrollment request not found'
            });
        }
        
        if (result.Item.status !== 'pending') {
            return createResponse(400, {
                error: 'Bad Request',
                message: `Enrollment already ${result.Item.status}`
            });
        }
        
        // Update enrollment status
        const timestamp = new Date().toISOString();
        const newStatus = body.action === 'approve' ? 'approved' : 'rejected';
        
        const updateParams = {
            TableName: ENROLLMENTS_TABLE,
            Key: {
                studentId: enrollmentId,
                courseId: courseId
            },
            UpdateExpression: 'SET #status = :status, updatedAt = :updatedAt, approvedAt = :approvedAt, approvedBy = :approvedBy',
            ExpressionAttributeNames: {
                '#status': 'status'
            },
            ExpressionAttributeValues: {
                ':status': newStatus,
                ':updatedAt': timestamp,
                ':approvedAt': timestamp,
                ':approvedBy': userInfo.username
            },
            ReturnValues: 'ALL_NEW'
        };
        
        const updateResult = await dynamodb.update(updateParams).promise();
        
        return createResponse(200, {
            message: `Enrollment ${body.action}d successfully`,
            enrollment: updateResult.Attributes
        });
        
    } catch (error) {
        console.error('Error:', error);
        
        return createResponse(500, {
            error: 'Internal Server Error',
            message: 'Failed to process enrollment'
        });
    }
};


PATH: /elearning-platform/terraform/modules/compute/functions/create-course/index.js

const { 
    createResponse, 
    getUserInfo, 
    generateId, 
    validateRequiredFields,
    dynamodb 
} = require('/opt/nodejs/utils');

const COURSES_TABLE = process.env.COURSES_TABLE;

exports.handler = async (event) => {
    console.log('Event:', JSON.stringify(event, null, 2));
    
    try {
        // Get user info from Cognito authorizer
        const userInfo = await getUserInfo(event);
        
        // Only teachers can create courses
        if (!userInfo.isTeacher) {
            return createResponse(403, {
                error: 'Forbidden',
                message: 'Only teachers can create courses'
            });
        }
        
        // Parse request body
        const body = JSON.parse(event.body);
        
        // Validate required fields
        validateRequiredFields(body, ['name', 'description']);
        
        // Create course object
        const courseId = generateId();
        const timestamp = new Date().toISOString();
        
        const course = {
            courseId,
            name: body.name,
            description: body.description,
            teacherId: userInfo.username,
            teacherEmail: userInfo.email,
            createdAt: timestamp,
            updatedAt: timestamp,
            status: 'active'
        };
        
        // Save to DynamoDB
        const params = {
            TableName: COURSES_TABLE,
            Item: course
        };
        
        await dynamodb.put(params).promise();
        
        return createResponse(201, {
            message: 'Course created successfully',
            course
        });
        
    } catch (error) {
        console.error('Error:', error);
        
        if (error.message.includes('Missing required fields')) {
            return createResponse(400, {
                error: 'Bad Request',
                message: error.message
            });
        }
        
        return createResponse(500, {
            error: 'Internal Server Error',
            message: 'Failed to create course'
        });
    }
};


PATH: /elearning-platform/terraform/modules/compute/functions/get-presigned-url/index.js

const AWS = require('aws-sdk');
const s3 = new AWS.S3();
const { 
    createResponse, 
    getUserInfo,
    isOwner,
    generateId,
    validateRequiredFields,
    dynamodb 
} = require('/opt/nodejs/utils');

const DOCUMENTS_BUCKET = process.env.DOCUMENTS_BUCKET;
const DOCUMENTS_TABLE = process.env.DOCUMENTS_TABLE;
const COURSES_TABLE = process.env.COURSES_TABLE;

exports.handler = async (event) => {
    console.log('Event:', JSON.stringify(event, null, 2));
    
    try {
        const courseId = event.pathParameters.courseId;
        const userInfo = await getUserInfo(event);
        const body = JSON.parse(event.body);
        
        // Validate input
        validateRequiredFields(body, ['fileName', 'action']);
        
        if (!['upload', 'download'].includes(body.action)) {
            return createResponse(400, {
                error: 'Bad Request',
                message: 'Action must be either "upload" or "download"'
            });
        }
        
        // For upload, only course owner can get URL
        if (body.action === 'upload') {
            const owner = await isOwner(courseId, userInfo.username, COURSES_TABLE);
            
            if (!owner) {
                return createResponse(403, {
                    error: 'Forbidden',
                    message: 'Only the course owner can upload documents'
                });
            }
            
            // Validate file type
            if (!body.fileName.toLowerCase().endsWith('.pdf')) {
                return createResponse(400, {
                    error: 'Bad Request',
                    message: 'Only PDF files are allowed'
                });
            }
            
            // Generate document ID and S3 key
            const documentId = generateId();
            const s3Key = `courses/${courseId}/documents/${documentId}/${body.fileName}`;
            
            // Generate presigned URL for upload
            const uploadUrl = await s3.getSignedUrlPromise('putObject', {
                Bucket: DOCUMENTS_BUCKET,
                Key: s3Key,
                Expires: 3600, // 1 hour
                ContentType: 'application/pdf'
            });
            
            // Save document metadata
            const timestamp = new Date().toISOString();
            const document = {
                courseId,
                documentId,
                name: body.fileName,
                s3Key,
                uploadedBy: userInfo.username,
                uploadedAt: timestamp,
                size: body.fileSize || 0,
                status: 'pending' // Will be 'ready' after processing
            };
            
            await dynamodb.put({
                TableName: DOCUMENTS_TABLE,
                Item: document
            }).promise();
            
            return createResponse(200, {
                message: 'Upload URL generated successfully',
                uploadUrl,
                documentId,
                expiresIn: 3600
            });
            
        } else {
            // For download, check if user has access (owner or enrolled student)
            const owner = await isOwner(courseId, userInfo.username, COURSES_TABLE);
            const enrolled = userInfo.isStudent ? 
                await require('/opt/nodejs/utils').isEnrolled(userInfo.username, courseId, process.env.ENROLLMENTS_TABLE) : 
                false;
            
            if (!owner && !enrolled) {
                return createResponse(403, {
                    error: 'Forbidden',
                    message: 'Access denied to this document'
                });
            }
            
            // Get document details
            const documentId = body.documentId;
            const docParams = {
                TableName: DOCUMENTS_TABLE,
                Key: { courseId, documentId }
            };
            
            const docResult = await dynamodb.get(docParams).promise();
            
            if (!docResult.Item) {
                return createResponse(404, {
                    error: 'Not Found',
                    message: 'Document not found'
                });
            }
            
            // Generate presigned URL for download
            const downloadUrl = await s3.getSignedUrlPromise('getObject', {
                Bucket: DOCUMENTS_BUCKET,
                Key: docResult.Item.s3Key,
                Expires: 3600 // 1 hour
            });
            
            return createResponse(200, {
                message: 'Download URL generated successfully',
                downloadUrl,
                fileName: docResult.Item.name,
                expiresIn: 3600
            });
        }
        
    } catch (error) {
        console.error('Error:', error);
        
        if (error.message.includes('Missing required fields')) {
            return createResponse(400, {
                error: 'Bad Request',
                message: error.message
            });
        }
        
        return createResponse(500, {
            error: 'Internal Server Error',
            message: 'Failed to generate presigned URL'
        });
    }
};


PATH: /elearning-platform/terraform/modules/compute/functions/get-quiz/index.js

const { 
    createResponse, 
    getUserInfo,
    isEnrolled,
    dynamodb 
} = require('/opt/nodejs/utils');

const QUIZZES_TABLE = process.env.QUIZZES_TABLE;
const DOCUMENTS_TABLE = process.env.DOCUMENTS_TABLE;
const ENROLLMENTS_TABLE = process.env.ENROLLMENTS_TABLE;

exports.handler = async (event) => {
    console.log('Event:', JSON.stringify(event, null, 2));
    
    try {
        const courseId = event.pathParameters.courseId;
        const documentId = event.pathParameters.documentId;
        const userInfo = await getUserInfo(event);
        
        // Only enrolled students can access quizzes
        if (!userInfo.isStudent) {
            return createResponse(403, {
                error: 'Forbidden',
                message: 'Only students can access quizzes'
            });
        }
        
        const enrolled = await isEnrolled(userInfo.username, courseId, ENROLLMENTS_TABLE);
        
        if (!enrolled) {
            return createResponse(403, {
                error: 'Forbidden',
                message: 'You must be enrolled in the course to access quizzes'
            });
        }
        
        // Get document to find quiz ID
        const docParams = {
            TableName: DOCUMENTS_TABLE,
            Key: { courseId, documentId }
        };
        
        const docResult = await dynamodb.get(docParams).promise();
        
        if (!docResult.Item) {
            return createResponse(404, {
                error: 'Not Found',
                message: 'Document not found'
            });
        }
        
        if (!docResult.Item.quizId) {
            return createResponse(404, {
                error: 'Not Found',
                message: 'No quiz available for this document yet'
            });
        }
        
        // Get quiz
        const quizParams = {
            TableName: QUIZZES_TABLE,
            Key: {
                documentId: documentId,
                quizId: docResult.Item.quizId
            }
        };
        
        const quizResult = await dynamodb.get(quizParams).promise();
        
        if (!quizResult.Item) {
            return createResponse(404, {
                error: 'Not Found',
                message: 'Quiz not found'
            });
        }
        
        // Remove correct answers before sending to student
        const questions = quizResult.Item.questions.map(q => ({
            questionId: q.questionId,
            question: q.question,
            options: q.options
            // Omit correctAnswer field
        }));
        
        return createResponse(200, {
            quiz: {
                quizId: quizResult.Item.quizId,
                documentId: quizResult.Item.documentId,
                documentName: docResult.Item.name,
                questions: questions,
                totalQuestions: questions.length
            }
        });
        
    } catch (error) {
        console.error('Error:', error);
        
        return createResponse(500, {
            error: 'Internal Server Error',
            message: 'Failed to get quiz'
        });
    }
};



PATH: /elearning-platform/terraform/modules/compute/functions/list-courses/index.js

const { 
    createResponse, 
    getUserInfo,
    dynamodb 
} = require('/opt/nodejs/utils');

const COURSES_TABLE = process.env.COURSES_TABLE;
const ENROLLMENTS_TABLE = process.env.ENROLLMENTS_TABLE;

exports.handler = async (event) => {
    console.log('Event:', JSON.stringify(event, null, 2));
    
    try {
        // Get user info from Cognito authorizer
        const userInfo = await getUserInfo(event);
        
        let courses = [];
        
        if (userInfo.isTeacher) {
            // Teachers see only their own courses
            const params = {
                TableName: COURSES_TABLE,
                IndexName: 'teacherId-index',
                KeyConditionExpression: 'teacherId = :teacherId',
                ExpressionAttributeValues: {
                    ':teacherId': userInfo.username
                }
            };
            
            const result = await dynamodb.query(params).promise();
            courses = result.Items || [];
            
        } else if (userInfo.isStudent) {
            // Students see all active courses with their enrollment status
            const scanParams = {
                TableName: COURSES_TABLE,
                FilterExpression: '#status = :status',
                ExpressionAttributeNames: {
                    '#status': 'status'
                },
                ExpressionAttributeValues: {
                    ':status': 'active'
                }
            };
            
            const coursesResult = await dynamodb.scan(scanParams).promise();
            const allCourses = coursesResult.Items || [];
            
            // Get student's enrollments
            const enrollmentParams = {
                TableName: ENROLLMENTS_TABLE,
                KeyConditionExpression: 'studentId = :studentId',
                ExpressionAttributeValues: {
                    ':studentId': userInfo.username
                }
            };
            
            const enrollmentsResult = await dynamodb.query(enrollmentParams).promise();
            const enrollments = enrollmentsResult.Items || [];
            
            // Create enrollment map for quick lookup
            const enrollmentMap = {};
            enrollments.forEach(enrollment => {
                enrollmentMap[enrollment.courseId] = enrollment.status;
            });
            
            // Add enrollment status to each course
            courses = allCourses.map(course => ({
                ...course,
                enrollmentStatus: enrollmentMap[course.courseId] || 'not_enrolled'
            }));
        }
        
        return createResponse(200, {
            courses,
            count: courses.length
        });
        
    } catch (error) {
        console.error('Error:', error);
        
        return createResponse(500, {
            error: 'Internal Server Error',
            message: 'Failed to list courses'
        });
    }
};


PATH: /elearning-platform/terraform/modules/compute/functions/list-documents/index.js

const { 
    createResponse, 
    getUserInfo,
    isOwner,
    isEnrolled,
    dynamodb 
} = require('/opt/nodejs/utils');

const DOCUMENTS_TABLE = process.env.DOCUMENTS_TABLE;
const ENROLLMENTS_TABLE = process.env.ENROLLMENTS_TABLE;

exports.handler = async (event) => {
    console.log('Event:', JSON.stringify(event, null, 2));
    
    try {
        const courseId = event.pathParameters.courseId;
        const userInfo = await getUserInfo(event);
        
        // Check if user has access to course documents
        const owner = await isOwner(courseId, userInfo.username, process.env.COURSES_TABLE);
        const enrolled = userInfo.isStudent ? 
            await isEnrolled(userInfo.username, courseId, ENROLLMENTS_TABLE) : 
            false;
        
        if (!owner && !enrolled) {
            return createResponse(403, {
                error: 'Forbidden',
                message: 'You do not have access to this course'
            });
        }
        
        // Query documents for the course
        const params = {
            TableName: DOCUMENTS_TABLE,
            KeyConditionExpression: 'courseId = :courseId',
            ExpressionAttributeValues: {
                ':courseId': courseId
            }
        };
        
        const result = await dynamodb.query(params).promise();
        const documents = result.Items || [];
        
        // Sort by upload date (newest first)
        documents.sort((a, b) => 
            new Date(b.uploadedAt).getTime() - new Date(a.uploadedAt).getTime()
        );
        
        // For students, only show ready documents
        const filteredDocuments = userInfo.isStudent ? 
            documents.filter(doc => doc.status === 'ready') : 
            documents;
        
        return createResponse(200, {
            courseId,
            documents: filteredDocuments,
            count: filteredDocuments.length
        });
        
    } catch (error) {
        console.error('Error:', error);
        
        return createResponse(500, {
            error: 'Internal Server Error',
            message: 'Failed to list documents'
        });
    }
};


PATH: /elearning-platform/terraform/modules/compute/functions/list-enrollments/index.js

const { 
    createResponse, 
    getUserInfo,
    isOwner,
    dynamodb 
} = require('/opt/nodejs/utils');

const ENROLLMENTS_TABLE = process.env.ENROLLMENTS_TABLE;

exports.handler = async (event) => {
    console.log('Event:', JSON.stringify(event, null, 2));
    
    try {
        const courseId = event.pathParameters.courseId;
        const userInfo = await getUserInfo(event);
        
        // Check if user is the course owner
        const owner = await isOwner(courseId, userInfo.username, process.env.COURSES_TABLE);
        
        if (!owner) {
            return createResponse(403, {
                error: 'Forbidden',
                message: 'Only the course owner can view enrollments'
            });
        }
        
        // Query enrollments for the course
        const params = {
            TableName: ENROLLMENTS_TABLE,
            IndexName: 'courseId-studentId-index',
            KeyConditionExpression: 'courseId = :courseId',
            ExpressionAttributeValues: {
                ':courseId': courseId
            }
        };
        
        const result = await dynamodb.query(params).promise();
        
        // Group enrollments by status
        const enrollments = result.Items || [];
        const grouped = {
            pending: [],
            approved: [],
            rejected: []
        };
        
        enrollments.forEach(enrollment => {
            if (grouped[enrollment.status]) {
                grouped[enrollment.status].push(enrollment);
            }
        });
        
        return createResponse(200, {
            courseId,
            enrollments: grouped,
            summary: {
                total: enrollments.length,
                pending: grouped.pending.length,
                approved: grouped.approved.length,
                rejected: grouped.rejected.length
            }
        });
        
    } catch (error) {
        console.error('Error:', error);
        
        return createResponse(500, {
            error: 'Internal Server Error',
            message: 'Failed to list enrollments'
        });
    }
};


PATH: /elearning-platform/terraform/modules/compute/functions/list-results/index.js

const { 
    createResponse, 
    getUserInfo,
    dynamodb 
} = require('/opt/nodejs/utils');

const RESULTS_TABLE = process.env.RESULTS_TABLE;

exports.handler = async (event) => {
    console.log('Event:', JSON.stringify(event, null, 2));
    
    try {
        const userInfo = await getUserInfo(event);
        
        // Students can only see their own results
        if (!userInfo.isStudent) {
            return createResponse(403, {
                error: 'Forbidden',
                message: 'Only students can view quiz results'
            });
        }
        
        // Query results for the student
        const params = {
            TableName: RESULTS_TABLE,
            KeyConditionExpression: 'studentId = :studentId',
            ExpressionAttributeValues: {
                ':studentId': userInfo.username
            },
            ScanIndexForward: false // Sort by timestamp descending (newest first)
        };
        
        const result = await dynamodb.query(params).promise();
        const results = result.Items || [];
        
        // Group results by quiz
        const groupedByQuiz = {};
        
        results.forEach(result => {
            if (!groupedByQuiz[result.quizId]) {
                groupedByQuiz[result.quizId] = {
                    quizId: result.quizId,
                    documentId: result.documentId,
                    courseId: result.courseId,
                    attempts: []
                };
            }
            
            groupedByQuiz[result.quizId].attempts.push({
                score: result.score,
                correctAnswers: result.correctAnswers,
                totalQuestions: result.totalQuestions,
                completedAt: result.completedAt,
                detailedResults: result.detailedResults
            });
        });
        
        // Convert to array and calculate best scores
        const quizResults = Object.values(groupedByQuiz).map(quiz => {
            const bestScore = Math.max(...quiz.attempts.map(a => a.score));
            const averageScore = quiz.attempts.reduce((sum, a) => sum + a.score, 0) / quiz.attempts.length;
            
            return {
                ...quiz,
                bestScore: bestScore,
                averageScore: Math.round(averageScore),
                totalAttempts: quiz.attempts.length,
                lastAttempt: quiz.attempts[0] // Already sorted by newest first
            };
        });
        
        return createResponse(200, {
            results: quizResults,
            summary: {
                totalQuizzesTaken: quizResults.length,
                totalAttempts: results.length,
                overallAverageScore: quizResults.length > 0 ? 
                    Math.round(quizResults.reduce((sum, q) => sum + q.averageScore, 0) / quizResults.length) : 
                    0
            }
        });
        
    } catch (error) {
        console.error('Error:', error);
        
        return createResponse(500, {
            error: 'Internal Server Error',
            message: 'Failed to list results'
        });
    }
};



PATH: /elearning-platform/terraform/modules/compute/functions/manage-course/index.js

const { 
    createResponse, 
    getUserInfo,
    isOwner,
    validateRequiredFields,
    dynamodb 
} = require('/opt/nodejs/utils');

const COURSES_TABLE = process.env.COURSES_TABLE;

exports.handler = async (event) => {
    console.log('Event:', JSON.stringify(event, null, 2));
    
    try {
        const courseId = event.pathParameters.courseId;
        const httpMethod = event.httpMethod;
        const userInfo = await getUserInfo(event);
        
        // GET: Anyone can view course details
        if (httpMethod === 'GET') {
            const params = {
                TableName: COURSES_TABLE,
                Key: { courseId }
            };
            
            const result = await dynamodb.get(params).promise();
            
            if (!result.Item) {
                return createResponse(404, {
                    error: 'Not Found',
                    message: 'Course not found'
                });
            }
            
            return createResponse(200, {
                course: result.Item
            });
        }
        
        // For PUT and DELETE, only the course owner can perform these actions
        const owner = await isOwner(courseId, userInfo.username, COURSES_TABLE);
        
        if (!owner) {
            return createResponse(403, {
                error: 'Forbidden',
                message: 'Only the course owner can perform this action'
            });
        }
        
        // PUT: Update course
        if (httpMethod === 'PUT') {
            const body = JSON.parse(event.body);
            validateRequiredFields(body, ['name', 'description']);
            
            const params = {
                TableName: COURSES_TABLE,
                Key: { courseId },
                UpdateExpression: 'SET #name = :name, description = :description, updatedAt = :updatedAt',
                ExpressionAttributeNames: {
                    '#name': 'name'
                },
                ExpressionAttributeValues: {
                    ':name': body.name,
                    ':description': body.description,
                    ':updatedAt': new Date().toISOString()
                },
                ReturnValues: 'ALL_NEW'
            };
            
            const result = await dynamodb.update(params).promise();
            
            return createResponse(200, {
                message: 'Course updated successfully',
                course: result.Attributes
            });
        }
        
        // DELETE: Delete course
        if (httpMethod === 'DELETE') {
            // Soft delete by updating status
            const params = {
                TableName: COURSES_TABLE,
                Key: { courseId },
                UpdateExpression: 'SET #status = :status, updatedAt = :updatedAt',
                ExpressionAttributeNames: {
                    '#status': 'status'
                },
                ExpressionAttributeValues: {
                    ':status': 'deleted',
                    ':updatedAt': new Date().toISOString()
                },
                ReturnValues: 'ALL_NEW'
            };
            
            await dynamodb.update(params).promise();
            
            return createResponse(200, {
                message: 'Course deleted successfully'
            });
        }
        
        return createResponse(405, {
            error: 'Method Not Allowed',
            message: `Method ${httpMethod} not allowed`
        });
        
    } catch (error) {
        console.error('Error:', error);
        
        if (error.message.includes('Missing required fields')) {
            return createResponse(400, {
                error: 'Bad Request',
                message: error.message
            });
        }
        
        return createResponse(500, {
            error: 'Internal Server Error',
            message: 'Failed to process request'
        });
    }
};


PATH: /elearning-platform/terraform/modules/compute/functions/manage-document/index.js

const AWS = require('aws-sdk');
const s3 = new AWS.S3();
const { 
    createResponse, 
    getUserInfo,
    isOwner,
    isEnrolled,
    dynamodb 
} = require('/opt/nodejs/utils');

const DOCUMENTS_TABLE = process.env.DOCUMENTS_TABLE;
const DOCUMENTS_BUCKET = process.env.DOCUMENTS_BUCKET;
const COURSES_TABLE = process.env.COURSES_TABLE;
const QUIZZES_TABLE = process.env.QUIZZES_TABLE;

exports.handler = async (event) => {
    console.log('Event:', JSON.stringify(event, null, 2));
    
    try {
        const courseId = event.pathParameters.courseId;
        const documentId = event.pathParameters.documentId;
        const httpMethod = event.httpMethod;
        const userInfo = await getUserInfo(event);
        
        // GET: Get document details (with download URL)
        if (httpMethod === 'GET') {
            // Check access
            const owner = await isOwner(courseId, userInfo.username, COURSES_TABLE);
            const enrolled = userInfo.isStudent ? 
                await isEnrolled(userInfo.username, courseId, process.env.ENROLLMENTS_TABLE) : 
                false;
            
            if (!owner && !enrolled) {
                return createResponse(403, {
                    error: 'Forbidden',
                    message: 'Access denied to this document'
                });
            }
            
            // Get document
            const params = {
                TableName: DOCUMENTS_TABLE,
                Key: { courseId, documentId }
            };
            
            const result = await dynamodb.get(params).promise();
            
            if (!result.Item) {
                return createResponse(404, {
                    error: 'Not Found',
                    message: 'Document not found'
                });
            }
            
            // Generate download URL
            const downloadUrl = await s3.getSignedUrlPromise('getObject', {
                Bucket: DOCUMENTS_BUCKET,
                Key: result.Item.s3Key,
                Expires: 3600
            });
            
            return createResponse(200, {
                document: result.Item,
                downloadUrl,
                expiresIn: 3600
            });
        }
        
        // DELETE: Delete document (owner only)
        if (httpMethod === 'DELETE') {
            const owner = await isOwner(courseId, userInfo.username, COURSES_TABLE);
            
            if (!owner) {
                return createResponse(403, {
                    error: 'Forbidden',
                    message: 'Only the course owner can delete documents'
                });
            }
            
            // Get document details
            const getParams = {
                TableName: DOCUMENTS_TABLE,
                Key: { courseId, documentId }
            };
            
            const docResult = await dynamodb.get(getParams).promise();
            
            if (!docResult.Item) {
                return createResponse(404, {
                    error: 'Not Found',
                    message: 'Document not found'
                });
            }
            
            // Delete from S3
            try {
                await s3.deleteObject({
                    Bucket: DOCUMENTS_BUCKET,
                    Key: docResult.Item.s3Key
                }).promise();
            } catch (s3Error) {
                console.error('S3 deletion error:', s3Error);
            }
            
            // Delete from DynamoDB
            await dynamodb.delete({
                TableName: DOCUMENTS_TABLE,
                Key: { courseId, documentId }
            }).promise();
            
            // Delete associated quiz if exists
            if (docResult.Item.quizId) {
                try {
                    await dynamodb.delete({
                        TableName: QUIZZES_TABLE,
                        Key: { 
                            documentId: documentId,
                            quizId: docResult.Item.quizId 
                        }
                    }).promise();
                } catch (quizError) {
                    console.error('Quiz deletion error:', quizError);
                }
            }
            
            return createResponse(200, {
                message: 'Document deleted successfully'
            });
        }
        
        return createResponse(405, {
            error: 'Method Not Allowed',
            message: `Method ${httpMethod} not allowed`
        });
        
    } catch (error) {
        console.error('Error:', error);
        
        return createResponse(500, {
            error: 'Internal Server Error',
            message: 'Failed to process document request'
        });
    }
};


PATH: /elearning-platform/terraform/modules/compute/functions/request-enrollment/index.js

const { 
    createResponse, 
    getUserInfo,
    generateId,
    dynamodb 
} = require('/opt/nodejs/utils');

const AWS = require('aws-sdk');
const sns = new AWS.SNS();

const ENROLLMENTS_TABLE = process.env.ENROLLMENTS_TABLE;
const COURSES_TABLE = process.env.COURSES_TABLE;
const SNS_TOPIC_ARN = process.env.SNS_TOPIC_ARN;

exports.handler = async (event) => {
    console.log('Event:', JSON.stringify(event, null, 2));
    
    try {
        const courseId = event.pathParameters.courseId;
        const userInfo = await getUserInfo(event);
        
        // Only students can request enrollment
        if (!userInfo.isStudent) {
            return createResponse(403, {
                error: 'Forbidden',
                message: 'Only students can request enrollment'
            });
        }
        
        // Check if course exists
        const courseParams = {
            TableName: COURSES_TABLE,
            Key: { courseId }
        };
        
        const courseResult = await dynamodb.get(courseParams).promise();
        
        if (!courseResult.Item || courseResult.Item.status !== 'active') {
            return createResponse(404, {
                error: 'Not Found',
                message: 'Course not found or not active'
            });
        }
        
        const course = courseResult.Item;
        
        // Check if already enrolled or pending
        const existingParams = {
            TableName: ENROLLMENTS_TABLE,
            Key: {
                studentId: userInfo.username,
                courseId: courseId
            }
        };
        
        const existingResult = await dynamodb.get(existingParams).promise();
        
        if (existingResult.Item) {
            return createResponse(400, {
                error: 'Bad Request',
                message: `Enrollment already ${existingResult.Item.status}`
            });
        }
        
        // Create enrollment request
        const timestamp = new Date().toISOString();
        const enrollment = {
            studentId: userInfo.username,
            studentEmail: userInfo.email,
            courseId: courseId,
            courseName: course.name,
            teacherId: course.teacherId,
            status: 'pending',
            requestedAt: timestamp,
            updatedAt: timestamp
        };
        
        const putParams = {
            TableName: ENROLLMENTS_TABLE,
            Item: enrollment
        };
        
        await dynamodb.put(putParams).promise();
        
        // Send notification to teacher if SNS is configured
        if (SNS_TOPIC_ARN) {
            try {
                const message = {
                    teacherId: course.teacherId,
                    teacherEmail: course.teacherEmail,
                    courseName: course.name,
                    courseId: courseId,
                    studentEmail: userInfo.email,
                    studentName: userInfo.username,
                    requestedAt: timestamp
                };
                
                await sns.publish({
                    TopicArn: SNS_TOPIC_ARN,
                    Subject: `New enrollment request for ${course.name}`,
                    Message: JSON.stringify(message),
                    MessageAttributes: {
                        teacherEmail: {
                            DataType: 'String',
                            StringValue: course.teacherEmail
                        }
                    }
                }).promise();
            } catch (snsError) {
                console.error('SNS notification failed:', snsError);
                // Don't fail the enrollment if notification fails
            }
        }
        
        return createResponse(201, {
            message: 'Enrollment request submitted successfully',
            enrollment
        });
        
    } catch (error) {
        console.error('Error:', error);
        
        return createResponse(500, {
            error: 'Internal Server Error',
            message: 'Failed to request enrollment'
        });
    }
};


PATH: /elearning-platform/terraform/modules/compute/functions/submit-quiz-results/index.js

const { 
    createResponse, 
    getUserInfo,
    isEnrolled,
    validateRequiredFields,
    dynamodb 
} = require('/opt/nodejs/utils');

const RESULTS_TABLE = process.env.RESULTS_TABLE;
const QUIZZES_TABLE = process.env.QUIZZES_TABLE;
const ENROLLMENTS_TABLE = process.env.ENROLLMENTS_TABLE;

exports.handler = async (event) => {
    console.log('Event:', JSON.stringify(event, null, 2));
    
    try {
        const courseId = event.pathParameters.courseId;
        const documentId = event.pathParameters.documentId;
        const userInfo = await getUserInfo(event);
        const body = JSON.parse(event.body);
        
        // Validate input
        validateRequiredFields(body, ['quizId', 'answers']);
        
        // Only enrolled students can submit quiz results
        if (!userInfo.isStudent) {
            return createResponse(403, {
                error: 'Forbidden',
                message: 'Only students can submit quiz results'
            });
        }
        
        const enrolled = await isEnrolled(userInfo.username, courseId, ENROLLMENTS_TABLE);
        
        if (!enrolled) {
            return createResponse(403, {
                error: 'Forbidden',
                message: 'You must be enrolled in the course to submit quiz results'
            });
        }
        
        // Get quiz with correct answers
        const quizParams = {
            TableName: QUIZZES_TABLE,
            Key: {
                documentId: documentId,
                quizId: body.quizId
            }
        };
        
        const quizResult = await dynamodb.get(quizParams).promise();
        
        if (!quizResult.Item) {
            return createResponse(404, {
                error: 'Not Found',
                message: 'Quiz not found'
            });
        }
        
        const quiz = quizResult.Item;
        
        // Calculate score
        let correctAnswers = 0;
        const detailedResults = [];
        
        quiz.questions.forEach(question => {
            const studentAnswer = body.answers[question.questionId];
            const isCorrect = studentAnswer === question.correctAnswer;
            
            if (isCorrect) {
                correctAnswers++;
            }
            
            detailedResults.push({
                questionId: question.questionId,
                question: question.question,
                studentAnswer: studentAnswer || null,
                correctAnswer: question.correctAnswer,
                isCorrect: isCorrect
            });
        });
        
        const score = Math.round((correctAnswers / quiz.questions.length) * 100);
        
        // Save result
        const timestamp = new Date().toISOString();
        const result = {
            studentId: userInfo.username,
            quizIdTimestamp: `${body.quizId}#${timestamp}`,
            quizId: body.quizId,
            documentId: documentId,
            courseId: courseId,
            score: score,
            correctAnswers: correctAnswers,
            totalQuestions: quiz.questions.length,
            answers: body.answers,
            detailedResults: detailedResults,
            completedAt: timestamp
        };
        
        await dynamodb.put({
            TableName: RESULTS_TABLE,
            Item: result
        }).promise();
        
        return createResponse(201, {
            message: 'Quiz results submitted successfully',
            result: {
                score: score,
                correctAnswers: correctAnswers,
                totalQuestions: quiz.questions.length,
                detailedResults: detailedResults,
                completedAt: timestamp
            }
        });
        
    } catch (error) {
        console.error('Error:', error);
        
        if (error.message.includes('Missing required fields')) {
            return createResponse(400, {
                error: 'Bad Request',
                message: error.message
            });
        }
        
        return createResponse(500, {
            error: 'Internal Server Error',
            message: 'Failed to submit quiz results'
        });
    }
};


PATH: /elearning-platform/terraform/modules/compute/layers/shared/nodejs/package.json

{
  "name": "shared-layer",
  "version": "1.0.0",
  "description": "Shared utilities for Lambda functions",
  "main": "utils.js"
}


PATH: /elearning-platform/terraform/modules/compute/layers/shared/nodejs/utils.js

const AWS = require('aws-sdk');
const dynamodb = new AWS.DynamoDB.DocumentClient();
const cognito = new AWS.CognitoIdentityServiceProvider();

// Standard HTTP response helper
const createResponse = (statusCode, body, headers = {}) => {
    return {
        statusCode,
        headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Credentials': true,
            ...headers
        },
        body: JSON.stringify(body)
    };
};

// Extract user info from Cognito authorizer context
const getUserInfo = async (event) => {
    const claims = event.requestContext.authorizer.claims;
    const username = claims['cognito:username'];
    const email = claims.email;
    const groups = claims['cognito:groups'] ? claims['cognito:groups'].split(',') : [];
    
    return {
        username,
        email,
        groups,
        isTeacher: groups.includes('Docenti'),
        isStudent: groups.includes('Studenti')
    };
};

// Check if user owns a course
const isOwner = async (courseId, username, coursesTableName) => {
    const params = {
        TableName: coursesTableName,
        Key: { courseId }
    };
    
    try {
        const result = await dynamodb.get(params).promise();
        return result.Item && result.Item.teacherId === username;
    } catch (error) {
        console.error('Error checking ownership:', error);
        return false;
    }
};

// Check if student is enrolled in course
const isEnrolled = async (studentId, courseId, enrollmentsTableName) => {
    const params = {
        TableName: enrollmentsTableName,
        Key: { studentId, courseId }
    };
    
    try {
        const result = await dynamodb.get(params).promise();
        return result.Item && result.Item.status === 'approved';
    } catch (error) {
        console.error('Error checking enrollment:', error);
        return false;
    }
};

// Generate unique ID
const generateId = () => {
    const timestamp = Date.now().toString(36);
    const randomStr = Math.random().toString(36).substr(2, 9);
    return `${timestamp}-${randomStr}`;
};

// Validate required fields
const validateRequiredFields = (data, requiredFields) => {
    const missingFields = requiredFields.filter(field => !data[field]);
    if (missingFields.length > 0) {
        throw new Error(`Missing required fields: ${missingFields.join(', ')}`);
    }
};

// DynamoDB batch operations helper
const batchGet = async (tableName, keys) => {
    const chunks = [];
    for (let i = 0; i < keys.length; i += 100) {
        chunks.push(keys.slice(i, i + 100));
    }
    
    const results = [];
    for (const chunk of chunks) {
        const params = {
            RequestItems: {
                [tableName]: {
                    Keys: chunk
                }
            }
        };
        
        const response = await dynamodb.batchGet(params).promise();
        results.push(...(response.Responses[tableName] || []));
    }
    
    return results;
};

// Safe JSON parse
const safeJsonParse = (str, defaultValue = null) => {
    try {
        return JSON.parse(str);
    } catch (error) {
        return defaultValue;
    }
};

module.exports = {
    createResponse,
    getUserInfo,
    isOwner,
    isEnrolled,
    generateId,
    validateRequiredFields,
    batchGet,
    safeJsonParse,
    dynamodb,
    cognito
};


PATH: /elearning-platform/terraform/modules/compute_ecs/iam.tf

# IAM Role for ECS Task
resource "aws_iam_role" "ecs_task_role" {
  name = "${var.project_name}-${var.environment}-ecs-task-role"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "ecs-tasks.amazonaws.com"
        }
      }
    ]
  })
}

# IAM Policy for ECS Task
resource "aws_iam_role_policy" "ecs_task_policy" {
  name = "${var.project_name}-${var.environment}-ecs-task-policy"
  role = aws_iam_role.ecs_task_role.id
  
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "s3:GetObject",
          "s3:PutObject"
        ]
        Resource = "${var.documents_bucket_arn}/*"
      },
      {
        Effect = "Allow"
        Action = [
          "dynamodb:GetItem",
          "dynamodb:PutItem",
          "dynamodb:UpdateItem"
        ]
        Resource = [
          var.documents_table_arn,
          var.quizzes_table_arn
        ]
      },
      {
        Effect = "Allow"
        Action = [
          "textract:StartDocumentTextDetection",
          "textract:GetDocumentTextDetection",
          "textract:AnalyzeDocument",
          "textract:DetectDocumentText"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "secretsmanager:GetSecretValue"
        ]
        Resource = aws_secretsmanager_secret.openai_api_key.arn
      }
    ]
  })
}

# IAM Role for ECS Execution
resource "aws_iam_role" "ecs_execution_role" {
  name = "${var.project_name}-${var.environment}-ecs-execution-role"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "ecs-tasks.amazonaws.com"
        }
      }
    ]
  })
}

# Attach managed policy for execution role
resource "aws_iam_role_policy_attachment" "ecs_execution_role_policy" {
  role       = aws_iam_role.ecs_execution_role.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"
}

# Additional policy for ECR access
resource "aws_iam_role_policy" "ecs_execution_ecr_policy" {
  name = "${var.project_name}-${var.environment}-ecs-execution-ecr-policy"
  role = aws_iam_role.ecs_execution_role.id
  
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "ecr:GetAuthorizationToken",
          "ecr:BatchCheckLayerAvailability",
          "ecr:GetDownloadUrlForLayer",
          "ecr:BatchGetImage"
        ]
        Resource = "*"
      }
    ]
  })
}

# IAM Role for ECS Instances
resource "aws_iam_role" "ecs_instance_role" {
  name = "${var.project_name}-${var.environment}-ecs-instance-role"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "ec2.amazonaws.com"
        }
      }
    ]
  })
}

# Attach managed policy for ECS instances
resource "aws_iam_role_policy_attachment" "ecs_instance_role_policy" {
  role       = aws_iam_role.ecs_instance_role.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role"
}

# Instance profile for ECS instances
resource "aws_iam_instance_profile" "ecs_instance" {
  name = "${var.project_name}-${var.environment}-ecs-instance-profile"
  role = aws_iam_role.ecs_instance_role.name
}


PATH: /elearning-platform/terraform/modules/compute_ecs/lambda_orchestrator.tf

# Lambda Orchestrator per triggerare ECS tasks
resource "aws_lambda_function" "ecs_orchestrator" {
  filename         = "${path.module}/functions/ecs-orchestrator.zip"
  function_name    = "${var.project_name}-${var.environment}-ecs-orchestrator"
  role            = aws_iam_role.lambda_orchestrator_role.arn
  handler         = "index.handler"
  runtime         = "nodejs18.x"
  timeout         = 300
  memory_size     = 256
  
  environment {
    variables = {
      ECS_CLUSTER_NAME     = aws_ecs_cluster.main.name
      TASK_DEFINITION_ARN  = aws_ecs_task_definition.quiz_processor.arn
      SUBNET_IDS           = join(",", var.private_subnet_ids)
      SECURITY_GROUP_ID    = var.ecs_security_group_id
      ASG_NAME            = aws_autoscaling_group.ecs_instances.name
    }
  }
  
  tags = {
    Name = "${var.project_name}-${var.environment}-ecs-orchestrator"
  }
}

# IAM Role for Lambda Orchestrator
resource "aws_iam_role" "lambda_orchestrator_role" {
  name = "${var.project_name}-${var.environment}-lambda-orchestrator-role"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

# IAM Policy for Lambda Orchestrator
resource "aws_iam_role_policy" "lambda_orchestrator_policy" {
  name = "${var.project_name}-${var.environment}-lambda-orchestrator-policy"
  role = aws_iam_role.lambda_orchestrator_role.id
  
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = "arn:aws:logs:*:*:*"
      },
      {
        Effect = "Allow"
        Action = [
          "ecs:RunTask",
          "ecs:DescribeTasks"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "iam:PassRole"
        ]
        Resource = [
          aws_iam_role.ecs_task_role.arn,
          aws_iam_role.ecs_execution_role.arn
        ]
      },
      {
        Effect = "Allow"
        Action = [
          "autoscaling:SetDesiredCapacity",
          "autoscaling:DescribeAutoScalingGroups"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "sqs:ReceiveMessage",
          "sqs:DeleteMessage",
          "sqs:GetQueueAttributes"
        ]
        Resource = var.document_processing_queue_arn
      }
    ]
  })
}

# CloudWatch Log Group
resource "aws_cloudwatch_log_group" "lambda_orchestrator" {
  name              = "/aws/lambda/${aws_lambda_function.ecs_orchestrator.function_name}"
  retention_in_days = 7
}

# Event Source Mapping for SQS
resource "aws_lambda_event_source_mapping" "sqs_to_orchestrator" {
  event_source_arn = var.document_processing_queue_arn
  function_name    = aws_lambda_function.ecs_orchestrator.arn
  batch_size       = 1
}

# Lambda permission for SQS
resource "aws_lambda_permission" "sqs_invoke" {
  statement_id  = "AllowSQSInvoke"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.ecs_orchestrator.function_name
  principal     = "sqs.amazonaws.com"
  source_arn    = var.document_processing_queue_arn
}


PATH: /elearning-platform/terraform/modules/compute_ecs/main.tf

# ECR Repository
resource "aws_ecr_repository" "quiz_processor" {
  name                 = "${var.project_name}-${var.environment}-quiz-processor"
  image_tag_mutability = "MUTABLE"
  
  image_scanning_configuration {
    scan_on_push = true
  }
  
  tags = {
    Name = "${var.project_name}-${var.environment}-quiz-processor"
  }
}

# ECR Lifecycle Policy
resource "aws_ecr_lifecycle_policy" "quiz_processor" {
  repository = aws_ecr_repository.quiz_processor.name
  
  policy = jsonencode({
    rules = [
      {
        rulePriority = 1
        description  = "Keep last 10 images"
        selection = {
          tagStatus     = "tagged"
          tagPrefixList = ["v"]
          countType     = "imageCountMoreThan"
          countNumber   = 10
        }
        action = {
          type = "expire"
        }
      }
    ]
  })
}

# ECS Cluster
resource "aws_ecs_cluster" "main" {
  name = "${var.project_name}-${var.environment}-cluster"
  
  setting {
    name  = "containerInsights"
    value = "disabled"  # Free Tier
  }
  
  tags = {
    Name = "${var.project_name}-${var.environment}-cluster"
  }
}

# Launch Template per ECS instances
resource "aws_launch_template" "ecs_instances" {
  name_prefix   = "${var.project_name}-${var.environment}-ecs-"
  image_id      = data.aws_ami.ecs_optimized.id
  instance_type = "t3.micro"
  
  iam_instance_profile {
    name = aws_iam_instance_profile.ecs_instance.name
  }
  
  vpc_security_group_ids = [var.ecs_security_group_id]
  
  user_data = base64encode(<<-EOF
    #!/bin/bash
    echo ECS_CLUSTER=${aws_ecs_cluster.main.name} >> /etc/ecs/ecs.config
    echo ECS_ENABLE_TASK_IAM_ROLE=true >> /etc/ecs/ecs.config
  EOF
  )
  
  tag_specifications {
    resource_type = "instance"
    tags = {
      Name = "${var.project_name}-${var.environment}-ecs-instance"
    }
  }
}

# Auto Scaling Group
resource "aws_autoscaling_group" "ecs_instances" {
  name                = "${var.project_name}-${var.environment}-ecs-asg"
  vpc_zone_identifier = var.private_subnet_ids
  min_size            = 0
  max_size            = 1
  desired_capacity    = 0  # Start with 0 to save costs
  
  launch_template {
    id      = aws_launch_template.ecs_instances.id
    version = "$Latest"
  }
  
  tag {
    key                 = "Name"
    value               = "${var.project_name}-${var.environment}-ecs-instance"
    propagate_at_launch = true
  }
}

# ECS Capacity Provider
resource "aws_ecs_capacity_provider" "main" {
  name = "${var.project_name}-${var.environment}-capacity-provider"
  
  auto_scaling_group_provider {
    auto_scaling_group_arn = aws_autoscaling_group.ecs_instances.arn
    
    managed_scaling {
      status                    = "ENABLED"
      target_capacity           = 100
      minimum_scaling_step_size = 1
      maximum_scaling_step_size = 1
    }
  }
}

# Associate capacity provider with cluster
resource "aws_ecs_cluster_capacity_providers" "main" {
  cluster_name = aws_ecs_cluster.main.name
  
  capacity_providers = [aws_ecs_capacity_provider.main.name]
  
  default_capacity_provider_strategy {
    base              = 0
    weight            = 100
    capacity_provider = aws_ecs_capacity_provider.main.name
  }
}

# Task Definition
resource "aws_ecs_task_definition" "quiz_processor" {
  family                   = "${var.project_name}-${var.environment}-quiz-processor"
  requires_compatibilities = ["EC2"]
  network_mode             = "bridge"
  cpu                      = "256"    # Ridotto da 512
  memory                   = "512"    # Ridotto da 1024 a 512 MB
  
  task_role_arn      = aws_iam_role.ecs_task_role.arn
  execution_role_arn = aws_iam_role.ecs_execution_role.arn
  
  container_definitions = jsonencode([
    {
      name  = "quiz-processor"
      image = "${aws_ecr_repository.quiz_processor.repository_url}:latest"
      
      memory = 512    # Ridotto da 1024
      cpu    = 256    # Ridotto da 512
      
      essential = true
      
      environment = [
        {
          name  = "AWS_DEFAULT_REGION"
          value = data.aws_region.current.name
        },
        {
          name  = "DOCUMENTS_BUCKET"
          value = var.documents_bucket_name
        },
        {
          name  = "DOCUMENTS_TABLE"
          value = var.documents_table_name
        },
        {
          name  = "QUIZZES_TABLE"
          value = var.quizzes_table_name
        },
        {
          name  = "OPENAI_API_KEY_SECRET_NAME"
          value = aws_secretsmanager_secret.openai_api_key.name
        }
      ]
      
      logConfiguration = {
        logDriver = "awslogs"
        options = {
          "awslogs-group"         = aws_cloudwatch_log_group.ecs_quiz_processor.name
          "awslogs-region"        = data.aws_region.current.name
          "awslogs-stream-prefix" = "ecs"
        }
      }
      
      healthCheck = {
        command     = ["CMD-SHELL", "curl -f http://localhost:8000/health || exit 1"]
        interval    = 30
        timeout     = 5
        retries     = 3
        startPeriod = 60
      }
    }
  ])
  
  tags = {
    Name = "${var.project_name}-${var.environment}-quiz-processor"
  }
}

# CloudWatch Log Group for ECS
resource "aws_cloudwatch_log_group" "ecs_quiz_processor" {
  name              = "/ecs/${var.project_name}-${var.environment}-quiz-processor"
  retention_in_days = 7
}

# Secrets Manager for OpenAI API Key
resource "aws_secretsmanager_secret" "openai_api_key" {
  name = "${var.project_name}-${var.environment}-openai-api-key"
  
  tags = {
    Name = "${var.project_name}-${var.environment}-openai-api-key"
  }
}

# Note: The actual secret value should be added manually via console or CLI
resource "aws_secretsmanager_secret_version" "openai_api_key" {
  secret_id     = aws_secretsmanager_secret.openai_api_key.id
  secret_string = "PLACEHOLDER-ADD-VIA-CONSOLE"
  
  lifecycle {
    ignore_changes = [secret_string]
  }
}

# Data sources
data "aws_region" "current" {}

data "aws_ami" "ecs_optimized" {
  most_recent = true
  owners      = ["amazon"]
  
  filter {
    name   = "name"
    values = ["amzn2-ami-ecs-hvm-*-x86_64-ebs"]
  }
}


PATH: /elearning-platform/terraform/modules/compute_ecs/outputs.tf

output "ecs_cluster_name" {
  description = "Nome del cluster ECS"
  value       = aws_ecs_cluster.main.name
}

output "ecs_cluster_arn" {
  description = "ARN del cluster ECS"
  value       = aws_ecs_cluster.main.arn
}

output "ecr_repository_url" {
  description = "URL del repository ECR"
  value       = aws_ecr_repository.quiz_processor.repository_url
}

output "task_definition_arn" {
  description = "ARN della task definition"
  value       = aws_ecs_task_definition.quiz_processor.arn
}

output "orchestrator_lambda_arn" {
  description = "ARN della Lambda orchestrator"
  value       = aws_lambda_function.ecs_orchestrator.arn
}

output "openai_secret_name" {
  description = "Nome del secret per OpenAI API key"
  value       = aws_secretsmanager_secret.openai_api_key.name
}


PATH: /elearning-platform/terraform/modules/compute_ecs/variables.tf

variable "project_name" {
  description = "Nome del progetto"
  type        = string
}

variable "environment" {
  description = "Nome dell'ambiente"
  type        = string
}

variable "vpc_id" {
  description = "ID del VPC"
  type        = string
}

variable "private_subnet_ids" {
  description = "IDs delle subnet private"
  type        = list(string)
}

variable "ecs_security_group_id" {
  description = "ID del security group ECS"
  type        = string
}

# DynamoDB Tables
variable "documents_table_name" {
  description = "Nome della tabella DynamoDB Documents"
  type        = string
}

variable "documents_table_arn" {
  description = "ARN della tabella DynamoDB Documents"
  type        = string
}

variable "quizzes_table_name" {
  description = "Nome della tabella DynamoDB Quizzes"
  type        = string
}

variable "quizzes_table_arn" {
  description = "ARN della tabella DynamoDB Quizzes"
  type        = string
}

# S3 Bucket
variable "documents_bucket_name" {
  description = "Nome del bucket S3 per i documenti"
  type        = string
}

variable "documents_bucket_arn" {
  description = "ARN del bucket S3 per i documenti"
  type        = string
}

# SQS Queue
variable "document_processing_queue_arn" {
  description = "ARN della coda SQS per processamento documenti"
  type        = string
}

variable "document_processing_queue_url" {
  description = "URL della coda SQS per processamento documenti"
  type        = string
}


PATH: /elearning-platform/terraform/modules/compute_ecs/prepare-lambda.sh

#!/bin/bash

# Prepara il file ZIP per Lambda Orchestrator

cd functions/ecs-orchestrator
npm init -y
npm install @aws-sdk/client-ecs @aws-sdk/client-auto-scaling
zip -r ../ecs-orchestrator.zip .
cd ../..


PATH: /elearning-platform/terraform/modules/compute_ecs/functions/ecs-orchestrator/index.js

const { ECSClient, RunTaskCommand, DescribeTasksCommand } = require('@aws-sdk/client-ecs');
const { AutoScalingClient, SetDesiredCapacityCommand, DescribeAutoScalingGroupsCommand } = require('@aws-sdk/client-auto-scaling');

const ecs = new ECSClient();
const autoscaling = new AutoScalingClient();

const CLUSTER_NAME = process.env.ECS_CLUSTER_NAME;
const TASK_DEFINITION_ARN = process.env.TASK_DEFINITION_ARN;
const SUBNET_IDS = process.env.SUBNET_IDS.split(',');
const SECURITY_GROUP_ID = process.env.SECURITY_GROUP_ID;
const ASG_NAME = process.env.ASG_NAME;

exports.handler = async (event) => {
    console.log('Event:', JSON.stringify(event, null, 2));
    
    try {
        // Parse SQS message
        const record = event.Records[0];
        const sqsMessage = JSON.parse(record.body);
        
        // Check if it's a test event
        if (sqsMessage.Event === 's3:TestEvent') {
            console.log('Ignoring S3 test event');
            return {
                statusCode: 200,
                body: JSON.stringify({ message: 'Test event ignored' })
            };
        }
        
        // Parse the actual S3 event from the SQS message
        const s3Records = sqsMessage.Records;
        if (!s3Records || s3Records.length === 0) {
            throw new Error('No S3 records found in message');
        }
        
        const s3Event = s3Records[0];
        const bucket = s3Event.s3.bucket.name;
        const key = decodeURIComponent(s3Event.s3.object.key.replace(/\+/g, ' '));
        
        console.log(`Processing file: ${key} from bucket: ${bucket}`);
        
        // Extract course ID and document ID from S3 key
        // Expected format: courses/{courseId}/documents/{documentId}/{filename}
        const keyParts = key.split('/');
        if (keyParts.length < 5 || keyParts[0] !== 'courses' || keyParts[2] !== 'documents') {
            throw new Error(`Invalid S3 key format: ${key}`);
        }
        
        const courseId = keyParts[1];
        const documentId = keyParts[3];
        
        console.log(`Course ID: ${courseId}, Document ID: ${documentId}`);
        
        // Check if we have ECS instances running
        const asgResponse = await autoscaling.send(new DescribeAutoScalingGroupsCommand({
            AutoScalingGroupNames: [ASG_NAME]
        }));
        
        const asg = asgResponse.AutoScalingGroups[0];
        const currentCapacity = asg.DesiredCapacity;
        
        // Start an instance if none are running
        if (currentCapacity === 0) {
            console.log('Starting ECS instance...');
            await autoscaling.send(new SetDesiredCapacityCommand({
                AutoScalingGroupName: ASG_NAME,
                DesiredCapacity: 1
            }));
            
            // Wait for instance to be ready
            console.log('Waiting for instance to start...');
            await new Promise(resolve => setTimeout(resolve, 90000)); // 90 seconds
        }
        
        // Run ECS task
        const runTaskParams = {
            cluster: CLUSTER_NAME,
            taskDefinition: TASK_DEFINITION_ARN,
            count: 1,
            launchType: 'EC2',
            overrides: {
                containerOverrides: [
                    {
                        name: 'quiz-processor',
                        environment: [
                            {
                                name: 'DOCUMENT_ID',
                                value: documentId
                            },
                            {
                                name: 'COURSE_ID',
                                value: courseId
                            },
                            {
                                name: 'S3_KEY',
                                value: key
                            }
                        ]
                    }
                ]
            }
        };
        
        console.log('Starting ECS task...');
        const runTaskResponse = await ecs.send(new RunTaskCommand(runTaskParams));
        
        if (runTaskResponse.failures && runTaskResponse.failures.length > 0) {
            console.error('Task failures:', runTaskResponse.failures);
            throw new Error('Failed to start ECS task');
        }
        
        console.log('ECS task started:', runTaskResponse.tasks[0].taskArn);
        
        // Schedule instance shutdown after 15 minutes if no other tasks
        setTimeout(async () => {
            try {
                // Describe all tasks in the cluster
                const listTasksResponse = await ecs.send(new DescribeTasksCommand({
                    cluster: CLUSTER_NAME
                }));
                
                const runningTasks = (listTasksResponse.tasks || []).filter(t => 
                    t.lastStatus === 'RUNNING' || t.lastStatus === 'PENDING'
                );
                
                if (runningTasks.length === 0) {
                    console.log('No running tasks, shutting down instance...');
                    await autoscaling.send(new SetDesiredCapacityCommand({
                        AutoScalingGroupName: ASG_NAME,
                        DesiredCapacity: 0
                    }));
                }
            } catch (error) {
                console.error('Error checking tasks:', error);
            }
        }, 900000); // 15 minutes
        
        return {
            statusCode: 200,
            body: JSON.stringify({
                message: 'Task started successfully',
                taskArn: runTaskResponse.tasks[0].taskArn
            })
        };
        
    } catch (error) {
        console.error('Error:', error);
        throw error; // Let SQS retry
    }
};



PATH: /elearning-platform/terraform/modules/elastic_beanstalk/main.tf

# Elastic Beanstalk Application
resource "aws_elastic_beanstalk_application" "frontend" {
  name        = "${var.project_name}-${var.environment}-frontend"
  description = "E-Learning Platform Frontend"
}

# Elastic Beanstalk Environment
resource "aws_elastic_beanstalk_environment" "frontend" {
  name                = "${var.project_name}-${var.environment}-frontend-env"
  application         = aws_elastic_beanstalk_application.frontend.name
  solution_stack_name = "64bit Amazon Linux 2 v4.2.0 running Docker"
  tier                = "WebServer"
  
  setting {
    namespace = "aws:ec2:vpc"
    name      = "VPCId"
    value     = var.vpc_id
  }
  
  setting {
    namespace = "aws:ec2:vpc"
    name      = "Subnets"
    value     = join(",", var.public_subnet_ids)
  }
  
  setting {
    namespace = "aws:ec2:vpc"
    name      = "ELBSubnets"
    value     = join(",", var.public_subnet_ids)
  }
  
  setting {
    namespace = "aws:ec2:instances"
    name      = "InstanceTypes"
    value     = "t3.medium"
  }
  
  setting {
    namespace = "aws:autoscaling:asg"
    name      = "MinSize"
    value     = "1"
  }
  
  setting {
    namespace = "aws:autoscaling:asg"
    name      = "MaxSize"
    value     = "2"
  }
  
  setting {
    namespace = "aws:elasticbeanstalk:environment"
    name      = "EnvironmentType"
    value     = "LoadBalanced"
  }
  
  setting {
    namespace = "aws:elasticbeanstalk:environment"
    name      = "LoadBalancerType"
    value     = "classic"
  }

  setting {
    namespace = "aws:autoscaling:launchconfiguration"
    name      = "IamInstanceProfile"
    value     = aws_iam_instance_profile.elastic_beanstalk_ec2.name
  }
  
  # Serviva solo per ALB, adesso sto usando un Classic Load Balancer (ELB)
  # setting {
  #   namespace = "aws:elbv2:loadbalancer"
  #   name      = "SecurityGroups"
  #   value     = var.alb_security_group_id
  # }

  # Setting per elb (per Classic)
  setting {
    namespace = "aws:elb:loadbalancer"
    name      = "SecurityGroups"
    value     = var.alb_security_group_id
  }
  
  setting {
    namespace = "aws:elasticbeanstalk:application:environment"
    name      = "REACT_APP_AWS_REGION"
    value     = data.aws_region.current.name
  }
  
  setting {
    namespace = "aws:elasticbeanstalk:application:environment"
    name      = "REACT_APP_USER_POOL_ID"
    value     = var.user_pool_id
  }
  
  setting {
    namespace = "aws:elasticbeanstalk:application:environment"
    name      = "REACT_APP_USER_POOL_CLIENT_ID"
    value     = var.user_pool_client_id
  }
  
  setting {
    namespace = "aws:elasticbeanstalk:application:environment"
    name      = "REACT_APP_API_ENDPOINT"
    value     = var.api_gateway_url
  }
  
  tags = {
    Name = "${var.project_name}-${var.environment}-frontend-env"
  }
}

# IAM Role for Elastic Beanstalk
resource "aws_iam_role" "elastic_beanstalk_ec2" {
  name = "${var.project_name}-${var.environment}-eb-ec2-role"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "ec2.amazonaws.com"
        }
      }
    ]
  })
}

resource "aws_iam_role_policy_attachment" "elastic_beanstalk_web_tier" {
  role       = aws_iam_role.elastic_beanstalk_ec2.name
  policy_arn = "arn:aws:iam::aws:policy/AWSElasticBeanstalkWebTier"
}

resource "aws_iam_role_policy_attachment" "elastic_beanstalk_multicontainer_docker" {
  role       = aws_iam_role.elastic_beanstalk_ec2.name
  policy_arn = "arn:aws:iam::aws:policy/AWSElasticBeanstalkMulticontainerDocker"
}

resource "aws_iam_instance_profile" "elastic_beanstalk_ec2" {
  name = "${var.project_name}-${var.environment}-eb-ec2-profile"
  role = aws_iam_role.elastic_beanstalk_ec2.name
}

# Data source
data "aws_region" "current" {}


PATH: /elearning-platform/terraform/modules/elastic_beanstalk/outputs.tf

output "environment_url" {
  description = "URL dell'ambiente Elastic Beanstalk"
  value       = aws_elastic_beanstalk_environment.frontend.endpoint_url
}

output "environment_name" {
  description = "Nome dell'ambiente Elastic Beanstalk"
  value       = aws_elastic_beanstalk_environment.frontend.name
}

output "application_name" {
  description = "Nome dell'applicazione Elastic Beanstalk"
  value       = aws_elastic_beanstalk_application.frontend.name
}

output "environment_cname" {
  description = "CNAME dell'ambiente Elastic Beanstalk"
  value       = aws_elastic_beanstalk_environment.frontend.cname
}


PATH: /elearning-platform/terraform/modules/elastic_beanstalk/variables.tf

variable "project_name" {
  description = "Nome del progetto"
  type        = string
}

variable "environment" {
  description = "Nome dell'ambiente"
  type        = string
}

variable "vpc_id" {
  description = "ID del VPC"
  type        = string
}

variable "public_subnet_ids" {
  description = "IDs delle subnet pubbliche"
  type        = list(string)
}

variable "alb_security_group_id" {
  description = "ID del security group per ALB"
  type        = string
}

variable "user_pool_id" {
  description = "ID del Cognito User Pool"
  type        = string
}

variable "user_pool_client_id" {
  description = "ID del Cognito User Pool Client"
  type        = string
}

variable "api_gateway_url" {
  description = "URL dell'API Gateway"
  type        = string
}


PATH: /elearning-platform/terraform/modules/messaging/main.tf

# SQS Queue per processamento documenti
resource "aws_sqs_queue" "document_processing" {
  name                       = "${var.project_name}-${var.environment}-document-processing"
  delay_seconds              = 0
  max_message_size           = 262144  # 256 KB
  message_retention_seconds  = 345600  # 4 giorni
  receive_wait_time_seconds  = 20      # Long polling
  visibility_timeout_seconds = 900     # 15 minuti per processing
  
  redrive_policy = jsonencode({
    deadLetterTargetArn = aws_sqs_queue.document_processing_dlq.arn
    maxReceiveCount     = 3
  })
  
  tags = {
    Name = "${var.project_name}-${var.environment}-document-processing"
  }
}

# Dead Letter Queue
resource "aws_sqs_queue" "document_processing_dlq" {
  name                      = "${var.project_name}-${var.environment}-document-processing-dlq"
  message_retention_seconds = 1209600  # 14 giorni
  
  tags = {
    Name = "${var.project_name}-${var.environment}-document-processing-dlq"
  }
}

# SNS Topic per notifiche enrollment
resource "aws_sns_topic" "enrollment_notifications" {
  name = "${var.project_name}-${var.environment}-enrollment-notifications"
  
  tags = {
    Name = "${var.project_name}-${var.environment}-enrollment-notifications"
  }
}

# SNS Topic per notifiche processamento documenti
resource "aws_sns_topic" "document_processing_notifications" {
  name = "${var.project_name}-${var.environment}-document-notifications"
  
  tags = {
    Name = "${var.project_name}-${var.environment}-document-notifications"
  }
}

# Subscription per admin email (se configurata)
resource "aws_sns_topic_subscription" "admin_enrollment_email" {
  count     = var.admin_email != "" ? 1 : 0
  topic_arn = aws_sns_topic.enrollment_notifications.arn
  protocol  = "email"
  endpoint  = var.admin_email
}


PATH: /elearning-platform/terraform/modules/messaging/outputs.tf

output "document_processing_queue_arn" {
  description = "ARN della coda SQS per processamento documenti"
  value       = aws_sqs_queue.document_processing.arn
}

output "document_processing_queue_url" {
  description = "URL della coda SQS per processamento documenti"
  value       = aws_sqs_queue.document_processing.url
}

output "enrollment_notifications_topic_arn" {
  description = "ARN del topic SNS per notifiche enrollment"
  value       = aws_sns_topic.enrollment_notifications.arn
}

output "document_processing_notifications_topic_arn" {
  description = "ARN del topic SNS per notifiche documenti"
  value       = aws_sns_topic.document_processing_notifications.arn
}


PATH: /elearning-platform/terraform/modules/messaging/variables.tf

variable "project_name" {
  description = "Nome del progetto"
  type        = string
}

variable "environment" {
  description = "Nome dell'ambiente"
  type        = string
}

variable "admin_email" {
  description = "Email amministratore per notifiche"
  type        = string
  default     = ""
}



PATH: /elearning-platform/terraform/modules/networking/main.tf

# VPC
resource "aws_vpc" "main" {
  cidr_block           = var.vpc_cidr
  enable_dns_hostnames = true
  enable_dns_support   = true
  
  tags = {
    Name = "${var.project_name}-${var.environment}-vpc"
  }
}

# Internet Gateway
resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id
  
  tags = {
    Name = "${var.project_name}-${var.environment}-igw"
  }
}

# Elastic IP per NAT Gateway (solo uno con singola AZ)
resource "aws_eip" "nat" {
  domain = "vpc"
  
  tags = {
    Name = "${var.project_name}-${var.environment}-eip"
  }
}

# NAT Gateway (solo uno con singola AZ)
resource "aws_nat_gateway" "main" {
  allocation_id = aws_eip.nat.id
  subnet_id     = aws_subnet.public[0].id
  
  tags = {
    Name = "${var.project_name}-${var.environment}-nat"
  }
  
  depends_on = [aws_internet_gateway.main]
}

# Subnet Pubbliche
resource "aws_subnet" "public" {
  count                   = length(var.public_subnet_cidrs)
  vpc_id                  = aws_vpc.main.id
  cidr_block              = var.public_subnet_cidrs[count.index]
  availability_zone       = var.availability_zones[count.index]
  map_public_ip_on_launch = true
  
  tags = {
    Name = "${var.project_name}-${var.environment}-public-subnet-${count.index + 1}"
    Type = "public"
  }
}

# Subnet Private
resource "aws_subnet" "private" {
  count             = length(var.private_subnet_cidrs)
  vpc_id            = aws_vpc.main.id
  cidr_block        = var.private_subnet_cidrs[count.index]
  availability_zone = var.availability_zones[count.index]
  
  tags = {
    Name = "${var.project_name}-${var.environment}-private-subnet-${count.index + 1}"
    Type = "private"
  }
}

# Route Table Pubblica
resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id
  
  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.main.id
  }
  
  tags = {
    Name = "${var.project_name}-${var.environment}-public-rt"
  }
}

# Route Table Privata (singola con una AZ)
resource "aws_route_table" "private" {
  vpc_id = aws_vpc.main.id
  
  route {
    cidr_block     = "0.0.0.0/0"
    nat_gateway_id = aws_nat_gateway.main.id
  }
  
  tags = {
    Name = "${var.project_name}-${var.environment}-private-rt"
  }
}

# Associazioni Route Table
resource "aws_route_table_association" "public" {
  count          = length(aws_subnet.public)
  subnet_id      = aws_subnet.public[count.index].id
  route_table_id = aws_route_table.public.id
}

resource "aws_route_table_association" "private" {
  count          = length(aws_subnet.private)
  subnet_id      = aws_subnet.private[count.index].id
  route_table_id = aws_route_table.private.id
}

# VPC Endpoints per servizi AWS (risparmio costi)
resource "aws_vpc_endpoint" "s3" {
  vpc_id            = aws_vpc.main.id
  service_name      = "com.amazonaws.${data.aws_region.current.name}.s3"
  vpc_endpoint_type = "Gateway"
  route_table_ids   = [aws_route_table.public.id, aws_route_table.private.id]
  
  tags = {
    Name = "${var.project_name}-${var.environment}-s3-endpoint"
  }
}

resource "aws_vpc_endpoint" "dynamodb" {
  vpc_id            = aws_vpc.main.id
  service_name      = "com.amazonaws.${data.aws_region.current.name}.dynamodb"
  vpc_endpoint_type = "Gateway"
  route_table_ids   = [aws_route_table.public.id, aws_route_table.private.id]
  
  tags = {
    Name = "${var.project_name}-${var.environment}-dynamodb-endpoint"
  }
}

# Data source per la regione corrente
data "aws_region" "current" {}


PATH: /elearning-platform/terraform/modules/networking/outputs.tf

output "vpc_id" {
  description = "ID del VPC"
  value       = aws_vpc.main.id
}

output "vpc_cidr" {
  description = "CIDR block del VPC"
  value       = aws_vpc.main.cidr_block
}

output "public_subnet_ids" {
  description = "IDs delle subnet pubbliche"
  value       = aws_subnet.public[*].id
}

output "private_subnet_ids" {
  description = "IDs delle subnet private"
  value       = aws_subnet.private[*].id
}

output "nat_gateway_id" {
  description = "ID del NAT Gateway"
  value       = aws_nat_gateway.main.id
}

output "alb_security_group_id" {
  description = "ID del security group ALB"
  value       = aws_security_group.alb.id
}

output "elastic_beanstalk_security_group_id" {
  description = "ID del security group Elastic Beanstalk"
  value       = aws_security_group.elastic_beanstalk.id
}

output "ecs_security_group_id" {
  description = "ID del security group ECS"
  value       = aws_security_group.ecs.id
}

output "lambda_security_group_id" {
  description = "ID del security group Lambda"
  value       = aws_security_group.lambda.id
}

output "rds_security_group_id" {
  description = "ID del security group RDS"
  value       = aws_security_group.rds.id
}

output "s3_vpc_endpoint_id" {
  description = "ID del VPC endpoint S3"
  value       = aws_vpc_endpoint.s3.id
}

output "dynamodb_vpc_endpoint_id" {
  description = "ID del VPC endpoint DynamoDB"
  value       = aws_vpc_endpoint.dynamodb.id
}


PATH: /elearning-platform/terraform/modules/networking/security.tf


# Security Group per ALB (Application Load Balancer)
resource "aws_security_group" "alb" {
  name        = "${var.project_name}-${var.environment}-alb-sg"
  description = "Security group per Application Load Balancer"
  vpc_id      = aws_vpc.main.id
  
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "HTTP from anywhere"
  }
  
  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "HTTPS from anywhere"
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow all outbound traffic"
  }
  
  tags = {
    Name = "${var.project_name}-${var.environment}-alb-sg"
  }
}

# Security Group per Elastic Beanstalk
resource "aws_security_group" "elastic_beanstalk" {
  name        = "${var.project_name}-${var.environment}-eb-sg"
  description = "Security group per Elastic Beanstalk instances"
  vpc_id      = aws_vpc.main.id
  
  ingress {
    from_port       = 80
    to_port         = 80
    protocol        = "tcp"
    security_groups = [aws_security_group.alb.id]
    description     = "HTTP from ALB"
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow all outbound traffic"
  }
  
  tags = {
    Name = "${var.project_name}-${var.environment}-eb-sg"
  }
}

# Security Group per ECS
resource "aws_security_group" "ecs" {
  name        = "${var.project_name}-${var.environment}-ecs-sg"
  description = "Security group per ECS tasks"
  vpc_id      = aws_vpc.main.id
  
  ingress {
    from_port   = 0
    to_port     = 65535
    protocol    = "tcp"
    self        = true
    description = "Allow communication between ECS tasks"
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow all outbound traffic"
  }
  
  tags = {
    Name = "${var.project_name}-${var.environment}-ecs-sg"
  }
}

# Security Group per Lambda (quando in VPC)
resource "aws_security_group" "lambda" {
  name        = "${var.project_name}-${var.environment}-lambda-sg"
  description = "Security group per Lambda functions"
  vpc_id      = aws_vpc.main.id
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow all outbound traffic"
  }
  
  tags = {
    Name = "${var.project_name}-${var.environment}-lambda-sg"
  }
}

# Security Group per RDS (futuro uso)
resource "aws_security_group" "rds" {
  name        = "${var.project_name}-${var.environment}-rds-sg"
  description = "Security group per RDS instances"
  vpc_id      = aws_vpc.main.id
  
  ingress {
    from_port = 3306
    to_port   = 3306
    protocol  = "tcp"
    security_groups = [
      aws_security_group.elastic_beanstalk.id,
      aws_security_group.ecs.id,
      aws_security_group.lambda.id
    ]
    description = "MySQL/Aurora from application layers"
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow all outbound traffic"
  }
  
  tags = {
    Name = "${var.project_name}-${var.environment}-rds-sg"
  }
}


PATH: /elearning-platform/terraform/modules/networking/variables.tf

variable "project_name" {
  description = "Nome del progetto"
  type        = string
}

variable "environment" {
  description = "Nome dell'ambiente"
  type        = string
}

variable "vpc_cidr" {
  description = "CIDR block per il VPC"
  type        = string
}

variable "public_subnet_cidrs" {
  description = "CIDR blocks per le subnet pubbliche"
  type        = list(string)
}

variable "private_subnet_cidrs" {
  description = "CIDR blocks per le subnet private"
  type        = list(string)
}

variable "availability_zones" {
  description = "Availability zones da utilizzare"
  type        = list(string)
}


PATH: /elearning-platform/terraform/modules/storage/dynamodb.tf

# Tabella Courses
resource "aws_dynamodb_table" "courses" {
  name         = "${var.project_name}-${var.environment}-courses"
  billing_mode = "PAY_PER_REQUEST"  # On-demand per Free Tier
  hash_key     = "courseId"
  
  attribute {
    name = "courseId"
    type = "S"
  }
  
  attribute {
    name = "teacherId"
    type = "S"
  }
  
  # GSI per query by teacher
  global_secondary_index {
    name            = "teacherId-index"
    hash_key        = "teacherId"
    projection_type = "ALL"
  }
  
  point_in_time_recovery {
    enabled = var.environment == "prod" ? true : false
  }
  
  server_side_encryption {
    enabled = true
  }
  
  tags = {
    Name = "${var.project_name}-${var.environment}-courses"
  }
}

# Tabella Enrollments
resource "aws_dynamodb_table" "enrollments" {
  name         = "${var.project_name}-${var.environment}-enrollments"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "studentId"
  range_key    = "courseId"
  
  attribute {
    name = "studentId"
    type = "S"
  }
  
  attribute {
    name = "courseId"
    type = "S"
  }
  
  # GSI per query by course
  global_secondary_index {
    name            = "courseId-studentId-index"
    hash_key        = "courseId"
    range_key       = "studentId"
    projection_type = "ALL"
  }
  
  server_side_encryption {
    enabled = true
  }
  
  tags = {
    Name = "${var.project_name}-${var.environment}-enrollments"
  }
}

# Tabella Documents
resource "aws_dynamodb_table" "documents" {
  name         = "${var.project_name}-${var.environment}-documents"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "courseId"
  range_key    = "documentId"
  
  attribute {
    name = "courseId"
    type = "S"
  }
  
  attribute {
    name = "documentId"
    type = "S"
  }
  
  server_side_encryption {
    enabled = true
  }
  
  tags = {
    Name = "${var.project_name}-${var.environment}-documents"
  }
}

# Tabella Quizzes
resource "aws_dynamodb_table" "quizzes" {
  name         = "${var.project_name}-${var.environment}-quizzes"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "documentId"
  range_key    = "quizId"
  
  attribute {
    name = "documentId"
    type = "S"
  }
  
  attribute {
    name = "quizId"
    type = "S"
  }
  
  server_side_encryption {
    enabled = true
  }
  
  tags = {
    Name = "${var.project_name}-${var.environment}-quizzes"
  }
}

# Tabella Results
resource "aws_dynamodb_table" "results" {
  name         = "${var.project_name}-${var.environment}-results"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "studentId"
  range_key    = "quizIdTimestamp"  # Formato: quizId#timestamp
  
  attribute {
    name = "studentId"
    type = "S"
  }
  
  attribute {
    name = "quizIdTimestamp"
    type = "S"
  }
  
  attribute {
    name = "quizId"
    type = "S"
  }
  
  # GSI per query by quiz
  global_secondary_index {
    name            = "quizId-index"
    hash_key        = "quizId"
    projection_type = "ALL"
  }
  
  server_side_encryption {
    enabled = true
  }
  
  tags = {
    Name = "${var.project_name}-${var.environment}-results"
  }
}


PATH: /elearning-platform/terraform/modules/storage/outputs.tf

# DynamoDB Tables
output "courses_table_name" {
  description = "Nome della tabella DynamoDB Courses"
  value       = aws_dynamodb_table.courses.name
}

output "courses_table_arn" {
  description = "ARN della tabella DynamoDB Courses"
  value       = aws_dynamodb_table.courses.arn
}

output "enrollments_table_name" {
  description = "Nome della tabella DynamoDB Enrollments"
  value       = aws_dynamodb_table.enrollments.name
}

output "enrollments_table_arn" {
  description = "ARN della tabella DynamoDB Enrollments"
  value       = aws_dynamodb_table.enrollments.arn
}

output "documents_table_name" {
  description = "Nome della tabella DynamoDB Documents"
  value       = aws_dynamodb_table.documents.name
}

output "documents_table_arn" {
  description = "ARN della tabella DynamoDB Documents"
  value       = aws_dynamodb_table.documents.arn
}

output "quizzes_table_name" {
  description = "Nome della tabella DynamoDB Quizzes"
  value       = aws_dynamodb_table.quizzes.name
}

output "quizzes_table_arn" {
  description = "ARN della tabella DynamoDB Quizzes"
  value       = aws_dynamodb_table.quizzes.arn
}

output "results_table_name" {
  description = "Nome della tabella DynamoDB Results"
  value       = aws_dynamodb_table.results.name
}

output "results_table_arn" {
  description = "ARN della tabella DynamoDB Results"
  value       = aws_dynamodb_table.results.arn
}

# S3 Buckets
output "documents_bucket_name" {
  description = "Nome del bucket S3 per i documenti"
  value       = aws_s3_bucket.documents.id
}

output "documents_bucket_arn" {
  description = "ARN del bucket S3 per i documenti"
  value       = aws_s3_bucket.documents.arn
}

output "documents_bucket_regional_domain_name" {
  description = "Regional domain name del bucket documenti"
  value       = aws_s3_bucket.documents.bucket_regional_domain_name
}

output "static_assets_bucket_name" {
  description = "Nome del bucket S3 per gli asset statici"
  value       = aws_s3_bucket.static_assets.id
}

output "static_assets_bucket_arn" {
  description = "ARN del bucket S3 per gli asset statici"
  value       = aws_s3_bucket.static_assets.arn
}

output "static_assets_bucket_regional_domain_name" {
  description = "Regional domain name del bucket static assets"
  value       = aws_s3_bucket.static_assets.bucket_regional_domain_name
}

output "static_assets_website_endpoint" {
  description = "Website endpoint del bucket static assets"
  value       = aws_s3_bucket_website_configuration.static_assets.website_endpoint
}


PATH: /elearning-platform/terraform/modules/storage/s3.tf

# Bucket per i documenti
resource "aws_s3_bucket" "documents" {
  bucket = "${var.project_name}-${var.environment}-documents-${random_string.bucket_suffix.result}"
  
  tags = {
    Name = "${var.project_name}-${var.environment}-documents"
  }
}

# Versioning per documents bucket
resource "aws_s3_bucket_versioning" "documents" {
  bucket = aws_s3_bucket.documents.id
  
  versioning_configuration {
    status = "Enabled"
  }
}

# Server-side encryption per documents bucket
resource "aws_s3_bucket_server_side_encryption_configuration" "documents" {
  bucket = aws_s3_bucket.documents.id
  
  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

# Lifecycle rule per archiviazione dopo 90 giorni
resource "aws_s3_bucket_lifecycle_configuration" "documents" {
  bucket = aws_s3_bucket.documents.id
  
  rule {
    id     = "archive-old-documents"
    status = "Enabled"
    
    transition {
      days          = 90
      storage_class = "GLACIER_IR"
    }
    
    noncurrent_version_transition {
      noncurrent_days = 30
      storage_class   = "GLACIER_IR"
    }
  }
}

# CORS configuration per upload diretto
resource "aws_s3_bucket_cors_configuration" "documents" {
  bucket = aws_s3_bucket.documents.id
  
  cors_rule {
    allowed_headers = ["*"]
    allowed_methods = ["GET", "PUT", "POST", "DELETE", "HEAD"]
    allowed_origins = ["*"]
    expose_headers  = ["ETag"]
    max_age_seconds = 3000
  }
}

# Block public access per documents bucket
resource "aws_s3_bucket_public_access_block" "documents" {
  bucket = aws_s3_bucket.documents.id
  
  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

# Bucket per static assets
resource "aws_s3_bucket" "static_assets" {
  bucket = "${var.project_name}-${var.environment}-static-${random_string.bucket_suffix.result}"
  
  tags = {
    Name = "${var.project_name}-${var.environment}-static-assets"
  }
}

# Server-side encryption per static assets bucket
resource "aws_s3_bucket_server_side_encryption_configuration" "static_assets" {
  bucket = aws_s3_bucket.static_assets.id
  
  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

# Static website hosting
resource "aws_s3_bucket_website_configuration" "static_assets" {
  bucket = aws_s3_bucket.static_assets.id
  
  index_document {
    suffix = "index.html"
  }
  
  error_document {
    key = "error.html"
  }
}

# CORS configuration per static assets
resource "aws_s3_bucket_cors_configuration" "static_assets" {
  bucket = aws_s3_bucket.static_assets.id
  
  cors_rule {
    allowed_headers = ["*"]
    allowed_methods = ["GET", "HEAD"]
    allowed_origins = ["*"]
    expose_headers  = ["ETag"]
    max_age_seconds = 3000
  }
}

# Block public access per static assets (sarà configurato con CloudFront nella Fase 5)
resource "aws_s3_bucket_public_access_block" "static_assets" {
  bucket = aws_s3_bucket.static_assets.id
  
  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

# Random suffix per bucket names
resource "random_string" "bucket_suffix" {
  length  = 8
  special = false
  upper   = false
}


PATH: /elearning-platform/terraform/modules/storage/variables.tf


variable "project_name" {
  description = "Nome del progetto"
  type        = string
}

variable "environment" {
  description = "Nome dell'ambiente"
  type        = string
}

# Rimosso non più necessario
# variable "domain_name" {
#   description = "Nome dominio per CORS"
#   type        = string
#   default     = "localhost:3000"
# }


